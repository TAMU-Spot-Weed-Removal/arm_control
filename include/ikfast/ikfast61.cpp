/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004b generated on 2022-11-10 11:47:16.832499
/// Generated using solver transform6d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004b);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.03) // 5D IK has some crazy degenerate cases, but can rely on jacobian refinment to make better, just need good starting point
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

template <typename T> struct ComplexLess
{
    bool operator()(const complex<T>& lhs, const complex<T>& rhs) const
    {
        if (real(lhs) < real(rhs)) {
            return true;
        }
        if (real(lhs) > real(rhs)) {
            return false;
        }
        return imag(lhs) < imag(rhs);
    }
};

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53;
x0=IKcos(j[0]);
x1=IKcos(j[1]);
x2=IKcos(j[2]);
x3=IKsin(j[1]);
x4=IKsin(j[2]);
x5=IKsin(j[3]);
x6=IKcos(j[3]);
x7=IKsin(j[4]);
x8=IKcos(j[4]);
x9=IKsin(j[0]);
x10=IKcos(j[5]);
x11=IKsin(j[5]);
x12=((0.057)*x9);
x13=((0.072)*x4);
x14=((0.1)*x5);
x15=((0.1)*x6);
x16=((0.218)*x2);
x17=((1.0)*x6);
x18=((1.0)*x2);
x19=((1.0)*x5);
x20=((1.0)*x9);
x21=((0.072)*x2);
x22=((1.0)*x0);
x23=(x2*x3);
x24=(x0*x1);
x25=(x8*x9);
x26=(x0*x8);
x27=(x3*x4);
x28=(x1*x9);
x29=(x1*x2);
x30=(x0*x7);
x31=((-1.0)*x5);
x32=(x1*x4);
x33=((-1.0)*x6);
x34=(x22*x27);
x35=(x20*x27);
x36=((((-1.0)*x1*x18))+x27);
x37=((((-1.0)*x32))+(((-1.0)*x18*x3)));
x38=(((x18*x3))+(((1.0)*x32)));
x39=(x36*x5);
x40=((((-1.0)*x34))+((x2*x24)));
x41=((((-1.0)*x35))+((x2*x28)));
x42=((((-1.0)*x22*x32))+(((-1.0)*x0*x18*x3)));
x43=((((-1.0)*x20*x32))+(((-1.0)*x18*x3*x9)));
x44=(x40*x6);
x45=(x43*x5);
x46=(x39+((x37*x6)));
x47=((((-1.0)*x17*x36))+(((-1.0)*x19*x38)));
x48=((((-1.0)*x17*x41))+(((-1.0)*x19*x43)));
x49=(((x19*(((((-1.0)*x34))+((x18*x24))))))+(((-1.0)*x17*x42)));
x50=(((x31*x42))+((x33*x40)));
x51=(((x31*(((((-1.0)*x18*x28))+x35))))+((x33*x43)));
x52=(x48*x7);
x53=(x50*x7);
eerot[0]=((((-1.0)*x20*x7))+((x8*((((x42*x5))+x44)))));
eerot[1]=(((x11*x49))+((x10*(((((-1.0)*x25))+x53)))));
eerot[2]=(((x10*x49))+((x11*(((((-1.0)*x53))+((x20*x8)))))));
IkReal x54=((1.0)*x0*x3);
eetrans[0]=((((-0.35)*x24))+((x6*(((((-1.0)*x13*x54))+((x21*x24))))))+((x5*(((((-1.0)*x13*x24))+(((-1.0)*x21*x54))))))+(((0.057)*x24*x4))+(((0.057)*x0*x23))+((x16*x24))+((x8*((((x15*x40))+((x14*x42))))))+(((-0.1)*x7*x9))+(((-0.218)*x0*x27)));
eerot[3]=(x30+((x8*((((x41*x6))+x45)))));
eerot[4]=(((x11*x51))+((x10*((x52+x26)))));
eerot[5]=(((x11*(((((-1.0)*x22*x8))+(((-1.0)*x52))))))+((x10*x51)));
IkReal x55=((1.0)*x13);
IkReal x56=(x3*x9);
eetrans[1]=((((-0.35)*x28))+((x5*(((((-1.0)*x28*x55))+(((-1.0)*x21*x56))))))+(((0.1)*x30))+((x8*((((x15*x41))+((x14*x43))))))+((x6*((((x21*x28))+(((-1.0)*x55*x56))))))+((x16*x28))+((x12*x32))+((x12*x23))+(((-0.218)*x27*x9)));
eerot[6]=(x46*x8);
eerot[7]=(((x10*x7*((((x31*x36))+((x33*x37))))))+((x11*x47)));
eerot[8]=(((x10*x47))+((x11*x46*x7)));
IkReal x57=((1.0)*x1);
IkReal x58=((1.0)*x3);
eetrans[2]=((0.105)+(((0.057)*x29))+(((0.35)*x3))+(((-1.0)*x16*x58))+(((-0.057)*x27))+((x8*((((x15*x37))+((x14*x36))))))+((x6*(((((-1.0)*x13*x57))+(((-1.0)*x21*x58))))))+((x5*(((((-1.0)*x21*x57))+((x13*x3))))))+(((-0.218)*x32)));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API const int* GetFreeIndices() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((-1.0)*r02);
new_r01=r01;
new_r02=r00;
new_px=(px+(((-0.1)*r00)));
new_r10=((-1.0)*r12);
new_r11=r11;
new_r12=r10;
new_py=(py+(((-0.1)*r10)));
new_r20=((-1.0)*r22);
new_r21=r21;
new_r22=r20;
new_pz=((-0.105)+(((-0.1)*r20))+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x59=((1.0)*px);
IkReal x60=((1.0)*pz);
IkReal x61=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x61))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x60)));
rxp0_2=((((-1.0)*r10*x59))+((py*r00)));
rxp1_0=((((-1.0)*r21*x61))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x60)));
rxp1_2=((((-1.0)*r11*x59))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x61)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x60)));
rxp2_2=((((-1.0)*r12*x59))+((py*r02)));
IkReal op[6+1], zeror[6];
int numroots;
IkReal x62=(npz*rxp0_2);
IkReal x63=(npx*r22);
IkReal x64=((2.304)*rxp1_2);
IkReal x65=(npy*r22);
IkReal x66=((1.152)*rxp1_2);
IkReal x67=((0.576)*rxp0_2*x65);
IkReal x68=((0.576)*r21*x62);
IkReal x69=(x68+(((-1.0)*x67)));
IkReal x70=((((1.152)*r20*x62))+((x65*x66)));
IkReal x71=((((1.152)*rxp0_2*x63))+((npz*r21*x66)));
IkReal x72=((((-1.0)*npz*r20*x64))+x67+((x63*x64))+(((-1.0)*x68)));
op[0]=x69;
op[1]=((((-1.0)*x70))+x71);
op[2]=x72;
op[3]=0;
op[4]=x72;
op[5]=((((-1.0)*x71))+x70);
op[6]=x69;
polyroots6(op,zeror,numroots);
IkReal j5array[6], cj5array[6], sj5array[6], tempj5array[1];
int numsolutions = 0;
for(int ij5 = 0; ij5 < numroots; ++ij5)
{
IkReal htj5 = zeror[ij5];
tempj5array[0]=((2.0)*(atan(htj5)));
for(int kj5 = 0; kj5 < 1; ++kj5)
{
j5array[numsolutions] = tempj5array[kj5];
if( j5array[numsolutions] > IKPI )
{
    j5array[numsolutions]-=IK2PI;
}
else if( j5array[numsolutions] < -IKPI )
{
    j5array[numsolutions]+=IK2PI;
}
sj5array[numsolutions] = IKsin(j5array[numsolutions]);
cj5array[numsolutions] = IKcos(j5array[numsolutions]);
numsolutions++;
}
}
bool j5valid[6]={true,true,true,true,true,true};
_nj5 = 6;
for(int ij5 = 0; ij5 < numsolutions; ++ij5)
    {
if( !j5valid[ij5] )
{
    continue;
}
    j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
htj5 = IKtan(j5/2);

_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < numsolutions; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
{
IkReal j4eval[1];
j4eval[0]=((IKabs((((cj5*r21))+((r20*sj5)))))+(IKabs(r22)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
j4eval[0]=((IKabs(npz))+(IKabs((((npx*sj5))+((cj5*npy))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x73=cj5*cj5;
IkReal x74=r22*r22;
IkReal x75=pz*pz;
IkReal x76=sj5*sj5;
IkReal x77=r21*r21;
IkReal x78=r20*r20;
IkReal x79=pp*pp;
IkReal x80=(npy*pz);
IkReal x81=((148843.545191282)*pp);
IkReal x82=(cj5*r21);
IkReal x83=((2.0)*pz);
IkReal x84=(npx*sj5);
IkReal x85=((385.802469135802)*pp);
IkReal x86=(r20*sj5);
IkReal x87=(r21*x73);
IkReal x88=(npz*pz*r22);
IkReal x89=(cj5*x86);
IkReal x90=((37210.8862978205)*x79);
IkReal x91=((148843.545191282)*x75);
IkReal x92=(x73*x77);
IkReal x93=(x76*x78);
IkReal x94=(npx*pz*r20*x76);
j4eval[0]=((((-1.0)*x81*x88))+(((-1.0)*pz*x81*x82*x84))+(((-1.0)*x80*x81*x89))+(((-1.0)*x80*x81*x87))+((x76*x91*(npx*npx)))+(((2.0)*x82*x86))+((x74*x85))+(((-771.604938271605)*x80*x89))+(((-771.604938271605)*x80*x87))+((x85*x93))+((x85*x92))+((x74*x90))+((x90*x93))+((x90*x92))+(((-771.604938271605)*x88))+x74+x93+x92+((x91*(npz*npz)))+(((-771.604938271605)*x94))+(((771.604938271605)*pp*x82*x86))+(((297687.090382564)*cj5*npy*x75*x84))+(((74421.7725956409)*x79*x82*x86))+(((-771.604938271605)*pz*x82*x84))+((x73*x91*(npy*npy)))+(((-1.0)*x81*x94)));
j4eval[1]=((IKabs((((pp*r22))+(((-1.0)*npz*x83))+(((0.005184)*r22)))))+(IKabs(((((-1.0)*x83*x84))+((pp*x86))+((pp*x82))+(((-2.0)*cj5*x80))+(((0.005184)*x82))+(((0.005184)*x86))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x95=(cj5*r21);
IkReal x96=(r20*sj5);
IkReal x97=((2.0)*pz);
IkReal x98=(((pp*r22))+(((-1.0)*npz*x97))+(((0.005184)*r22)));
IkReal x99=(((pp*x96))+((pp*x95))+(((-1.0)*npx*sj5*x97))+(((-1.0)*cj5*npy*x97))+(((0.005184)*x95))+(((0.005184)*x96)));
CheckValue<IkReal> x102 = IKatan2WithCheck(IkReal(x99),IkReal(x98),IKFAST_ATAN2_MAGTHRESH);
if(!x102.valid){
continue;
}
IkReal x100=((1.0)*(x102.value));
if((((x99*x99)+(x98*x98))) < -0.00001)
continue;
CheckValue<IkReal> x103=IKPowWithIntegerCheck(IKabs(IKsqrt(((x99*x99)+(x98*x98)))),-1);
if(!x103.valid){
continue;
}
if( (((x103.value)*(((((-0.144)*rxp1_2*sj5))+(((0.144)*cj5*rxp0_2)))))) < -1-IKFAST_SINCOS_THRESH || (((x103.value)*(((((-0.144)*rxp1_2*sj5))+(((0.144)*cj5*rxp0_2)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x101=IKasin(((x103.value)*(((((-0.144)*rxp1_2*sj5))+(((0.144)*cj5*rxp0_2))))));
j4array[0]=((((-1.0)*x100))+(((-1.0)*x101)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x100))+x101);
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x104=IKcos(j4);
IkReal x105=IKsin(j4);
IkReal x106=(sj5*x104);
IkReal x107=(cj5*x104);
evalcond[0]=(((r22*x105))+((r21*x107))+((r20*x106)));
evalcond[1]=(((npz*x105))+((npy*x107))+((npx*x106)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0eval[1];
j0eval[0]=((1.0)+((cj4*cj5*r11))+((r12*sj4))+((cj4*r10*sj5)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
IkReal x108=((1.0)*cj4);
j0eval[0]=((((-1.0)*cj5*r01*x108))+(((-1.0)*r00*sj5*x108))+(((-1.0)*r02*sj4)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
j0eval[0]=(((cj5*r11*sj4))+((r10*sj4*sj5))+(((13.8888888888889)*py))+(((-1.0)*cj4*r12)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x109=cj5*cj5;
IkReal x110=cj4*cj4;
IkReal x111=r10*r10;
IkReal x112=r00*r00;
IkReal x113=r11*r11;
IkReal x114=r01*r01;
IkReal x115=(r00*sj5);
IkReal x116=((0.072)*sj4);
IkReal x117=((0.041472)*cj5);
IkReal x118=(cj4*r12);
IkReal x119=((0.576)*py);
IkReal x120=(r10*sj5);
IkReal x121=(cj5*sj4);
IkReal x122=(cj4*r02);
IkReal x123=((0.576)*px);
IkReal x124=(r11*x120);
IkReal x125=(sj4*x122);
IkReal x126=((0.020736)*x112);
IkReal x127=((0.020736)*x111);
IkReal x128=((0.020736)*x110);
IkReal x129=((0.020736)*x109);
IkReal x130=(x109*x128);
CheckValue<IkReal> x139=IKPowWithIntegerCheck(((((-0.072)*x118))+py+((x116*x120))+((cj5*r11*x116))),-1);
if(!x139.valid){
continue;
}
IkReal x131=x139.value;
IkReal x132=(px*x131);
IkReal x133=((0.072)*x131);
IkReal x134=(x122*x133);
CheckValue<IkReal> x140=IKPowWithIntegerCheck(((((-0.072)*x118))+(((0.072)*r11*x121))+py+(((0.072)*sj4*x120))),-1);
if(!x140.valid){
continue;
}
IkReal x135=(cj5*r01*x116*(x140.value));
CheckValue<IkReal> x141=IKPowWithIntegerCheck(((((-0.072)*x118))+(((0.072)*r11*x121))+py+(((0.072)*sj4*x120))),-1);
if(!x141.valid){
continue;
}
IkReal x136=(x115*x116*(x141.value));
IkReal x137=(x135+x136+x132);
if(((((x117*x124))+(((-1.0)*x113*x130))+(((-1.0)*x118*x119))+(((4.0)*(py*py)))+((r01*x115*x117))+((sj4*x115*x123))+(((-1.0)*x110*x126))+(((-1.0)*x110*x127))+(((-1.0)*r01*x117*x125))+((x114*x129))+(((-1.0)*r11*sj4*x117*x118))+((x113*x129))+((r11*x119*x121))+x126+x127+(((-1.0)*x110*x117*x124))+((x128*(r12*r12)))+(((-0.041472)*sj4*x118*x120))+(((-1.0)*x109*x126))+(((-1.0)*x109*x127))+(((-1.0)*x114*x130))+(((-1.0)*r01*x110*x115*x117))+(((4.0)*(px*px)))+((r01*x121*x123))+(((-0.041472)*x115*x125))+((x109*x110*x127))+((x109*x110*x126))+((x128*(r02*r02)))+((sj4*x119*x120))+(((-1.0)*x122*x123)))) < -0.00001)
continue;
IkReal x138=((0.5)*x131*(IKsqrt((((x117*x124))+(((-1.0)*x113*x130))+(((-1.0)*x118*x119))+(((4.0)*(py*py)))+((r01*x115*x117))+((sj4*x115*x123))+(((-1.0)*x110*x126))+(((-1.0)*x110*x127))+(((-1.0)*r01*x117*x125))+((x114*x129))+(((-1.0)*r11*sj4*x117*x118))+((x113*x129))+((r11*x119*x121))+x126+x127+(((-1.0)*x110*x117*x124))+((x128*(r12*r12)))+(((-0.041472)*sj4*x118*x120))+(((-1.0)*x109*x126))+(((-1.0)*x109*x127))+(((-1.0)*x114*x130))+(((-1.0)*r01*x110*x115*x117))+(((4.0)*(px*px)))+((r01*x121*x123))+(((-0.041472)*x115*x125))+((x109*x110*x127))+((x109*x110*x126))+((x128*(r02*r02)))+((sj4*x119*x120))+(((-1.0)*x122*x123))))));
j0array[0]=((2.0)*(atan((x134+x138+(((-1.0)*x137))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((-2.0)*(atan((x137+x138+(((-1.0)*x134))))));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

innerfn(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x976=(cj4*cj5);
IkReal x977=(cj4*sj5);
CheckValue<IkReal> x980=IKPowWithIntegerCheck(((((-1.0)*r02*sj4))+(((-1.0)*r00*x977))+(((-1.0)*r01*x976))),-1);
if(!x980.valid){
continue;
}
IkReal x978=x980.value;
IkReal x979=(cj4*x978);
CheckValue<IkReal> x981=IKPowWithIntegerCheck(((((-1.0)*cj4*cj5*r01))+(((-1.0)*r02*sj4))+(((-1.0)*r00*x977))),-1);
if(!x981.valid){
continue;
}
CheckValue<IkReal> x982=IKPowWithIntegerCheck(((((-1.0)*cj4*r00*sj5))+(((-1.0)*r02*sj4))+(((-1.0)*r01*x976))),-1);
if(!x982.valid){
continue;
}
j0array[0]=((-2.0)*(atan((((r11*x976*(x981.value)))+(((-1.0)*x978))+((r10*x977*(x982.value)))+((r12*sj4*x978))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

innerfn(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x983=(cj4*cj5);
IkReal x984=(cj4*sj5);
CheckValue<IkReal> x986=IKPowWithIntegerCheck(((1.0)+((r12*sj4))+((r11*x983))+((r10*x984))),-1);
if(!x986.valid){
continue;
}
IkReal x985=x986.value;
j0array[0]=((-2.0)*(atan((((r01*x983*x985))+((r02*sj4*x985))+((r00*x984*x985))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

innerfn(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x988 = IKatan2WithCheck(IkReal((((npx*sj5))+((cj5*npy)))),IkReal(npz),IKFAST_ATAN2_MAGTHRESH);
if(!x988.valid){
continue;
}
IkReal x987=x988.value;
j4array[0]=((-1.0)*x987);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x987)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x989=IKcos(j4);
IkReal x990=IKsin(j4);
IkReal x991=((2.0)*pz);
IkReal x992=(cj5*x989);
IkReal x993=(r22*x990);
IkReal x994=(r20*sj5*x989);
evalcond[0]=(((r21*x992))+x993+x994);
evalcond[1]=((((-0.144)*rxp1_2*sj5))+((pp*r21*x992))+(((0.144)*cj5*rxp0_2))+(((0.005184)*r21*x992))+(((-1.0)*npz*x990*x991))+(((-1.0)*npx*sj5*x989*x991))+(((-1.0)*npy*x991*x992))+((pp*x994))+((pp*x993))+(((0.005184)*x993))+(((0.005184)*x994)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0eval[1];
j0eval[0]=((1.0)+((cj4*cj5*r11))+((r12*sj4))+((cj4*r10*sj5)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
IkReal x995=((1.0)*cj4);
j0eval[0]=((((-1.0)*r00*sj5*x995))+(((-1.0)*r02*sj4))+(((-1.0)*cj5*r01*x995)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
j0eval[0]=(((cj5*r11*sj4))+((r10*sj4*sj5))+(((13.8888888888889)*py))+(((-1.0)*cj4*r12)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x996=cj5*cj5;
IkReal x997=cj4*cj4;
IkReal x998=r10*r10;
IkReal x999=r00*r00;
IkReal x1000=r11*r11;
IkReal x1001=r01*r01;
IkReal x1002=(r00*sj5);
IkReal x1003=((0.072)*sj4);
IkReal x1004=((0.041472)*cj5);
IkReal x1005=(cj4*r12);
IkReal x1006=((0.576)*py);
IkReal x1007=(r10*sj5);
IkReal x1008=(cj5*sj4);
IkReal x1009=(cj4*r02);
IkReal x1010=((0.576)*px);
IkReal x1011=(r11*x1007);
IkReal x1012=(sj4*x1009);
IkReal x1013=((0.020736)*x999);
IkReal x1014=((0.020736)*x998);
IkReal x1015=((0.020736)*x997);
IkReal x1016=((0.020736)*x996);
IkReal x1017=(x1015*x996);
CheckValue<IkReal> x1026=IKPowWithIntegerCheck((((cj5*r11*x1003))+py+(((-0.072)*x1005))+((x1003*x1007))),-1);
if(!x1026.valid){
continue;
}
IkReal x1018=x1026.value;
IkReal x1019=(px*x1018);
IkReal x1020=((0.072)*x1018);
IkReal x1021=(x1009*x1020);
CheckValue<IkReal> x1027=IKPowWithIntegerCheck(((((0.072)*sj4*x1007))+py+(((-0.072)*x1005))+(((0.072)*r11*x1008))),-1);
if(!x1027.valid){
continue;
}
IkReal x1022=(cj5*r01*x1003*(x1027.value));
CheckValue<IkReal> x1028=IKPowWithIntegerCheck(((((0.072)*sj4*x1007))+py+(((-0.072)*x1005))+(((0.072)*r11*x1008))),-1);
if(!x1028.valid){
continue;
}
IkReal x1023=(x1002*x1003*(x1028.value));
IkReal x1024=(x1019+x1023+x1022);
if(((((x1014*x996*x997))+((x1015*(r02*r02)))+(((4.0)*(py*py)))+x1014+x1013+(((-1.0)*x1009*x1010))+((sj4*x1006*x1007))+(((-0.041472)*sj4*x1005*x1007))+(((-1.0)*x1004*x1011*x997))+((sj4*x1002*x1010))+((r01*x1002*x1004))+((x1015*(r12*r12)))+((x1013*x996*x997))+((x1000*x1016))+(((-1.0)*r11*sj4*x1004*x1005))+(((-1.0)*r01*x1004*x1012))+(((-1.0)*r01*x1002*x1004*x997))+(((-0.041472)*x1002*x1012))+(((-1.0)*x1013*x997))+(((-1.0)*x1013*x996))+(((-1.0)*x1005*x1006))+(((-1.0)*x1001*x1017))+((x1001*x1016))+(((4.0)*(px*px)))+((x1004*x1011))+((r11*x1006*x1008))+((r01*x1008*x1010))+(((-1.0)*x1014*x996))+(((-1.0)*x1014*x997))+(((-1.0)*x1000*x1017)))) < -0.00001)
continue;
IkReal x1025=((0.5)*x1018*(IKsqrt((((x1014*x996*x997))+((x1015*(r02*r02)))+(((4.0)*(py*py)))+x1014+x1013+(((-1.0)*x1009*x1010))+((sj4*x1006*x1007))+(((-0.041472)*sj4*x1005*x1007))+(((-1.0)*x1004*x1011*x997))+((sj4*x1002*x1010))+((r01*x1002*x1004))+((x1015*(r12*r12)))+((x1013*x996*x997))+((x1000*x1016))+(((-1.0)*r11*sj4*x1004*x1005))+(((-1.0)*r01*x1004*x1012))+(((-1.0)*r01*x1002*x1004*x997))+(((-0.041472)*x1002*x1012))+(((-1.0)*x1013*x997))+(((-1.0)*x1013*x996))+(((-1.0)*x1005*x1006))+(((-1.0)*x1001*x1017))+((x1001*x1016))+(((4.0)*(px*px)))+((x1004*x1011))+((r11*x1006*x1008))+((r01*x1008*x1010))+(((-1.0)*x1014*x996))+(((-1.0)*x1014*x997))+(((-1.0)*x1000*x1017))))));
j0array[0]=((2.0)*(atan((x1025+x1021+(((-1.0)*x1024))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((-2.0)*(atan((x1025+x1024+(((-1.0)*x1021))))));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

innerfn(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1029=(cj4*cj5);
IkReal x1030=(cj4*sj5);
CheckValue<IkReal> x1033=IKPowWithIntegerCheck(((((-1.0)*r00*x1030))+(((-1.0)*r01*x1029))+(((-1.0)*r02*sj4))),-1);
if(!x1033.valid){
continue;
}
IkReal x1031=x1033.value;
IkReal x1032=(cj4*x1031);
CheckValue<IkReal> x1034=IKPowWithIntegerCheck(((((-1.0)*r01*x1029))+(((-1.0)*cj4*r00*sj5))+(((-1.0)*r02*sj4))),-1);
if(!x1034.valid){
continue;
}
CheckValue<IkReal> x1035=IKPowWithIntegerCheck(((((-1.0)*r00*x1030))+(((-1.0)*cj4*cj5*r01))+(((-1.0)*r02*sj4))),-1);
if(!x1035.valid){
continue;
}
j0array[0]=((-2.0)*(atan(((((-1.0)*x1031))+((r10*x1030*(x1034.value)))+((r12*sj4*x1031))+((r11*x1029*(x1035.value)))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

innerfn(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1036=(cj4*cj5);
IkReal x1037=(cj4*sj5);
CheckValue<IkReal> x1039=IKPowWithIntegerCheck(((1.0)+((r10*x1037))+((r12*sj4))+((r11*x1036))),-1);
if(!x1039.valid){
continue;
}
IkReal x1038=x1039.value;
j0array[0]=((-2.0)*(atan((((r02*sj4*x1038))+((r01*x1036*x1038))+((r00*x1037*x1038))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

innerfn(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x1041 = IKatan2WithCheck(IkReal((((cj5*r21))+((r20*sj5)))),IkReal(r22),IKFAST_ATAN2_MAGTHRESH);
if(!x1041.valid){
continue;
}
IkReal x1040=x1041.value;
j4array[0]=((-1.0)*x1040);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1040)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x1042=IKcos(j4);
IkReal x1043=IKsin(j4);
IkReal x1044=((2.0)*pz);
IkReal x1045=(cj5*x1042);
IkReal x1046=(r22*x1043);
IkReal x1047=(npz*x1043);
IkReal x1048=(sj5*x1042);
evalcond[0]=(x1047+((npx*x1048))+((npy*x1045)));
evalcond[1]=((((-1.0)*npy*x1044*x1045))+((pp*r21*x1045))+(((0.005184)*r21*x1045))+(((-0.144)*rxp1_2*sj5))+(((-1.0)*x1044*x1047))+(((0.005184)*x1046))+(((0.005184)*r20*x1048))+(((0.144)*cj5*rxp0_2))+(((-1.0)*npx*x1044*x1048))+((pp*x1046))+((pp*r20*x1048)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0eval[1];
j0eval[0]=((1.0)+((cj4*cj5*r11))+((r12*sj4))+((cj4*r10*sj5)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
IkReal x1049=((1.0)*cj4);
j0eval[0]=((((-1.0)*r02*sj4))+(((-1.0)*cj5*r01*x1049))+(((-1.0)*r00*sj5*x1049)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
j0eval[0]=(((cj5*r11*sj4))+((r10*sj4*sj5))+(((13.8888888888889)*py))+(((-1.0)*cj4*r12)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x1050=cj5*cj5;
IkReal x1051=cj4*cj4;
IkReal x1052=r10*r10;
IkReal x1053=r00*r00;
IkReal x1054=r11*r11;
IkReal x1055=r01*r01;
IkReal x1056=(r00*sj5);
IkReal x1057=((0.072)*sj4);
IkReal x1058=((0.041472)*cj5);
IkReal x1059=(cj4*r12);
IkReal x1060=((0.576)*py);
IkReal x1061=(r10*sj5);
IkReal x1062=(cj5*sj4);
IkReal x1063=(cj4*r02);
IkReal x1064=((0.576)*px);
IkReal x1065=(r11*x1061);
IkReal x1066=(sj4*x1063);
IkReal x1067=((0.020736)*x1053);
IkReal x1068=((0.020736)*x1052);
IkReal x1069=((0.020736)*x1051);
IkReal x1070=((0.020736)*x1050);
IkReal x1071=(x1050*x1069);
CheckValue<IkReal> x1080=IKPowWithIntegerCheck((((cj5*r11*x1057))+((x1057*x1061))+(((-0.072)*x1059))+py),-1);
if(!x1080.valid){
continue;
}
IkReal x1072=x1080.value;
IkReal x1073=(px*x1072);
IkReal x1074=((0.072)*x1072);
IkReal x1075=(x1063*x1074);
CheckValue<IkReal> x1081=IKPowWithIntegerCheck(((((0.072)*r11*x1062))+(((-0.072)*x1059))+py+(((0.072)*sj4*x1061))),-1);
if(!x1081.valid){
continue;
}
IkReal x1076=(cj5*r01*x1057*(x1081.value));
CheckValue<IkReal> x1082=IKPowWithIntegerCheck(((((0.072)*r11*x1062))+(((-0.072)*x1059))+py+(((0.072)*sj4*x1061))),-1);
if(!x1082.valid){
continue;
}
IkReal x1077=(x1056*x1057*(x1082.value));
IkReal x1078=(x1076+x1077+x1073);
if(((((sj4*x1060*x1061))+(((-1.0)*x1063*x1064))+((x1069*(r02*r02)))+((x1055*x1070))+(((-0.041472)*sj4*x1059*x1061))+(((4.0)*(py*py)))+x1068+x1067+((x1069*(r12*r12)))+(((-1.0)*x1059*x1060))+((x1054*x1070))+((r01*x1062*x1064))+(((-1.0)*r01*x1051*x1056*x1058))+(((-1.0)*r01*x1058*x1066))+(((-1.0)*x1054*x1071))+(((4.0)*(px*px)))+((sj4*x1056*x1064))+(((-1.0)*x1055*x1071))+((r11*x1060*x1062))+(((-1.0)*x1051*x1058*x1065))+(((-1.0)*x1051*x1068))+(((-1.0)*x1051*x1067))+(((-1.0)*r11*sj4*x1058*x1059))+((r01*x1056*x1058))+((x1058*x1065))+((x1050*x1051*x1068))+((x1050*x1051*x1067))+(((-1.0)*x1050*x1067))+(((-1.0)*x1050*x1068))+(((-0.041472)*x1056*x1066)))) < -0.00001)
continue;
IkReal x1079=((0.5)*x1072*(IKsqrt((((sj4*x1060*x1061))+(((-1.0)*x1063*x1064))+((x1069*(r02*r02)))+((x1055*x1070))+(((-0.041472)*sj4*x1059*x1061))+(((4.0)*(py*py)))+x1068+x1067+((x1069*(r12*r12)))+(((-1.0)*x1059*x1060))+((x1054*x1070))+((r01*x1062*x1064))+(((-1.0)*r01*x1051*x1056*x1058))+(((-1.0)*r01*x1058*x1066))+(((-1.0)*x1054*x1071))+(((4.0)*(px*px)))+((sj4*x1056*x1064))+(((-1.0)*x1055*x1071))+((r11*x1060*x1062))+(((-1.0)*x1051*x1058*x1065))+(((-1.0)*x1051*x1068))+(((-1.0)*x1051*x1067))+(((-1.0)*r11*sj4*x1058*x1059))+((r01*x1056*x1058))+((x1058*x1065))+((x1050*x1051*x1068))+((x1050*x1051*x1067))+(((-1.0)*x1050*x1067))+(((-1.0)*x1050*x1068))+(((-0.041472)*x1056*x1066))))));
j0array[0]=((2.0)*(atan((x1079+x1075+(((-1.0)*x1078))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((-2.0)*(atan((x1078+x1079+(((-1.0)*x1075))))));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

innerfn(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1083=(cj4*cj5);
IkReal x1084=(cj4*sj5);
CheckValue<IkReal> x1087=IKPowWithIntegerCheck(((((-1.0)*r00*x1084))+(((-1.0)*r01*x1083))+(((-1.0)*r02*sj4))),-1);
if(!x1087.valid){
continue;
}
IkReal x1085=x1087.value;
IkReal x1086=(cj4*x1085);
CheckValue<IkReal> x1088=IKPowWithIntegerCheck(((((-1.0)*r00*x1084))+(((-1.0)*cj4*cj5*r01))+(((-1.0)*r02*sj4))),-1);
if(!x1088.valid){
continue;
}
CheckValue<IkReal> x1089=IKPowWithIntegerCheck(((((-1.0)*r01*x1083))+(((-1.0)*cj4*r00*sj5))+(((-1.0)*r02*sj4))),-1);
if(!x1089.valid){
continue;
}
j0array[0]=((-2.0)*(atan((((r12*sj4*x1085))+(((-1.0)*x1085))+((r11*x1083*(x1088.value)))+((r10*x1084*(x1089.value)))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

innerfn(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1090=(cj4*cj5);
IkReal x1091=(cj4*sj5);
CheckValue<IkReal> x1093=IKPowWithIntegerCheck(((1.0)+((r10*x1091))+((r11*x1090))+((r12*sj4))),-1);
if(!x1093.valid){
continue;
}
IkReal x1092=x1093.value;
j0array[0]=((-2.0)*(atan((((r02*sj4*x1092))+((r01*x1090*x1092))+((r00*x1091*x1092))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

innerfn(solutions);
}
}

}

}
}
}

}

}
    }
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    // sort roots hoping that it solution indices become more robust to slight change in coeffs
    std::sort(roots, roots+3, ComplexLess<IkReal>());

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && (abs(imag(roots[i])-imag(roots[j])) < 0.002 || abs(imag(roots[i])+imag(roots[j])) < 0.002) && abs(imag(roots[i])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    // sort roots hoping that it solution indices become more robust to slight change in coeffs
    std::sort(roots, roots+5, ComplexLess<IkReal>());

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && (abs(imag(roots[i])-imag(roots[j])) < 0.002 || abs(imag(roots[i])+imag(roots[j])) < 0.002) && abs(imag(roots[i])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    // sort roots hoping that it solution indices become more robust to slight change in coeffs
    std::sort(roots, roots+4, ComplexLess<IkReal>());

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && (abs(imag(roots[i])-imag(roots[j])) < 0.002 || abs(imag(roots[i])+imag(roots[j])) < 0.002) && abs(imag(roots[i])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    // sort roots hoping that it solution indices become more robust to slight change in coeffs
    std::sort(roots, roots+7, ComplexLess<IkReal>());

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && (abs(imag(roots[i])-imag(roots[j])) < 0.002 || abs(imag(roots[i])+imag(roots[j])) < 0.002) && abs(imag(roots[i])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    // sort roots hoping that it solution indices become more robust to slight change in coeffs
    std::sort(roots, roots+6, ComplexLess<IkReal>());

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && (abs(imag(roots[i])-imag(roots[j])) < 0.002 || abs(imag(roots[i])+imag(roots[j])) < 0.002) && abs(imag(roots[i])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    // sort roots hoping that it solution indices become more robust to slight change in coeffs
    std::sort(roots, roots+8, ComplexLess<IkReal>());

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && (abs(imag(roots[i])-imag(roots[j])) < 0.002 || abs(imag(roots[i])+imag(roots[j])) < 0.002) && abs(imag(roots[i])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
inline void innerfn(IkSolutionListBase<IkReal>& solutions) {
for(int fniter = 0; fniter < 1; ++fniter) {
IkReal op[8+1], zeror[8];
int numroots;
IkReal x142=((1.0)*px);
IkReal x143=((0.132)*cj0);
IkReal x144=((0.568)*cj0);
IkReal x145=((0.072)*cj4);
IkReal x146=(r22*x145);
IkReal x147=(r02*x145);
IkReal x148=((0.072)*sj4*sj5);
IkReal x149=((0.072)*cj5*sj4);
IkReal x150=(r01*x149);
IkReal x151=(r00*x148);
IkReal x152=(((r20*x148))+((r21*x149))+(((1.0)*pz)));
IkReal x153=(x151+x150+x142);
IkReal x154=((0.057)+(((-1.0)*x152))+x146);
IkReal x155=((-0.057)+(((-1.0)*x152))+x146);
IkReal x156=((((-1.0)*x143))+(((-1.0)*x153))+x147);
IkReal x157=((((-1.0)*x144))+(((-1.0)*x153))+x147);
IkReal x158=((((-1.0)*x153))+x143+x147);
IkReal x159=((((-1.0)*x153))+x144+x147);
IkReal gconst0=x154;
IkReal gconst1=x155;
IkReal gconst2=x156;
IkReal gconst3=x157;
IkReal gconst4=x154;
IkReal gconst5=x155;
IkReal gconst6=x156;
IkReal gconst7=x157;
IkReal gconst8=x155;
IkReal gconst9=x154;
IkReal gconst10=x158;
IkReal gconst11=x159;
IkReal gconst12=x155;
IkReal gconst13=x154;
IkReal gconst14=x158;
IkReal gconst15=x159;
IkReal x160=cj0*cj0;
IkReal x161=(gconst11*gconst13);
IkReal x162=((0.030096)*cj0);
IkReal x163=(cj0*gconst4);
IkReal x164=(gconst0*gconst11);
IkReal x165=(gconst5*gconst6);
IkReal x166=((1.0)*gconst12);
IkReal x167=(cj0*gconst6);
IkReal x168=((0.049704)*gconst9);
IkReal x169=(gconst12*gconst8);
IkReal x170=(cj0*gconst3);
IkReal x171=(gconst0*gconst14);
IkReal x172=((0.129504)*gconst2);
IkReal x173=((0.3542)*cj0);
IkReal x174=(gconst11*gconst12);
IkReal x175=((0.114)*cj0);
IkReal x176=(gconst14*gconst9);
IkReal x177=((1.0)*gconst4);
IkReal x178=(gconst7*gconst8);
IkReal x179=((0.049704)*gconst1);
IkReal x180=((0.264)*gconst3);
IkReal x181=(gconst14*gconst5);
IkReal x182=(gconst10*gconst15);
IkReal x183=(gconst1*gconst5);
IkReal x184=(cj0*gconst14);
IkReal x185=(gconst3*gconst5);
IkReal x186=(gconst3*gconst6);
IkReal x187=(gconst0*gconst7);
IkReal x188=(gconst15*gconst8);
IkReal x189=((0.1596)*cj0);
IkReal x190=(gconst12*gconst15);
IkReal x191=(gconst1*gconst10);
IkReal x192=((1.0)*gconst13);
IkReal x193=(gconst10*gconst9);
IkReal x194=(gconst1*gconst12);
IkReal x195=(gconst2*gconst7);
IkReal x196=(gconst11*gconst8);
IkReal x197=((1.136)*gconst14);
IkReal x198=(gconst1*gconst2);
IkReal x199=(cj0*gconst11);
IkReal x200=((0.190096)*gconst11);
IkReal x201=(gconst4*gconst7);
IkReal x202=(gconst12*gconst9);
IkReal x203=(gconst1*gconst7);
IkReal x204=(gconst10*gconst13);
IkReal x205=((0.129504)*cj0);
IkReal x206=(gconst14*gconst3);
IkReal x207=(gconst2*gconst9);
IkReal x208=(gconst0*gconst3);
IkReal x209=(gconst1*gconst4);
IkReal x210=(gconst4*gconst9);
IkReal x211=(gconst13*gconst8);
IkReal x212=(gconst0*gconst5);
IkReal x213=(gconst11*gconst14);
IkReal x214=((0.190096)*x206);
IkReal x215=(gconst6*x200);
IkReal x216=((0.00636804)*x160);
IkReal x217=((0.012996)*x160);
IkReal x218=(gconst3*x187);
IkReal x219=((1.0)*x198);
IkReal x220=(gconst12*x160);
IkReal x221=((0.0090972)*x160);
IkReal x222=((0.092866224)*x160);
IkReal x223=((0.049704)*gconst12*x170);
IkReal x224=(x167*x168);
IkReal x225=(x179*x184);
IkReal x226=((0.049704)*gconst11*x163);
IkReal x227=(x210*x217);
IkReal x228=(x194*x217);
IkReal x229=(x214+x215+x216+x228+x223+x225+x224+x227+x226);
op[0]=(((gconst14*gconst8*x161))+(((-1.0)*gconst14*x200))+(((-1.0)*gconst11*x166*x188))+(((-1.0)*x168*x184))+(((-1.0)*x202*x217))+((x182*x202))+(((-0.049704)*cj0*x174))+(((-1.0)*gconst10*x176*x192)));
op[1]=((((-0.0090972)*x220))+(((-1.0)*gconst9*x221))+(((-1.0)*x197*x204))+(((-1.0)*gconst13*x175*x176))+(((-1.0)*gconst12*x175*x193))+(((-1.136)*gconst10*x176))+((gconst8*x161*x175))+(((0.198816)*x213))+((x196*x197))+((gconst15*x169*x175))+(((1.136)*gconst12*x182))+(((-0.264)*gconst11*x188))+(((-0.0347928)*x184))+(((0.264)*gconst9*x182))+(((-0.198816)*x160*x202))+(((-1.0)*gconst14*x175*x211))+(((-0.0347928)*x199))+(((0.264)*gconst14*x161))+((gconst11*x169*x175))+((gconst9*x175*x190))+(((-0.264)*gconst15*x174))+(((-1.0)*x173*x176))+(((-1.0)*x173*x174))+(((-1.0)*gconst13*x175*x193)));
op[2]=((((-1.0)*x204*x205))+((x161*x162))+((x161*x171))+(((-1.0)*gconst9*x222))+((x162*x188))+(((-1.0)*gconst10*gconst12*x205))+(((-1.0)*x189*x193))+((x206*x211))+(((-1.0)*gconst11*x177*x188))+((gconst12*gconst7*x193))+((gconst15*gconst9*x162))+(((-1.0)*gconst14*x191*x192))+(((-1.0)*gconst13*gconst9*x217))+(((-1.0)*gconst15*x164*x166))+(((0.32832)*cj0*x174))+((x182*x210))+((x190*x207))+(((-1.0)*gconst6*x192*x193))+(((-1.0)*gconst3*x166*x188))+(((0.16872)*cj0*x176))+((x189*x196))+((x189*x190))+(((-0.425036224)*x184))+(((-1.0)*gconst10*gconst5*x176))+(((-0.070843776)*x199))+(((-0.185476176)*x220))+(((-0.747388)*x160*x202))+(((-1.290496)*gconst10*gconst14))+(((-0.069696)*gconst11*gconst15))+(((-1.0)*gconst2*x176*x192))+(((0.628112)*x213))+(((0.299904)*x182))+(((-0.129504)*gconst8*x184))+(((-1.0)*x211*x217))+(((-0.1596)*gconst13*x184))+(((-1.0)*gconst11*x166*x178))+((x181*x196))+((x182*x194))+(((-1.0)*x229))+((gconst6*gconst8*x161))+(((-1.0)*x169*x217)));
op[3]=((((0.0421344)*cj0*gconst15))+(((0.114)*cj0*gconst15*gconst4*gconst8))+(((0.114)*cj0*gconst15*gconst4*gconst9))+(((-0.3542)*cj0*gconst1*gconst14))+(((-0.0347928)*cj0*gconst6))+(((-0.0347928)*cj0*gconst3))+(((0.114)*cj0*gconst1*gconst12*gconst15))+(((0.264)*gconst11*gconst14*gconst5))+(((0.114)*cj0*gconst0*gconst11*gconst13))+(((0.114)*cj0*gconst0*gconst11*gconst12))+(((-0.0090972)*gconst4*(cj0*cj0)))+(((0.264)*gconst15*gconst2*gconst9))+(((-0.264)*gconst15*gconst3*gconst8))+(((-0.1813056)*cj0*gconst10))+(((-0.198816)*gconst1*gconst12*(cj0*cj0)))+(((1.136)*gconst14*gconst3*gconst8))+(((-1.136)*gconst1*gconst10*gconst14))+(((0.198816)*gconst14*gconst3))+(((-0.114)*cj0*gconst13*gconst6*gconst8))+(((-0.114)*cj0*gconst13*gconst6*gconst9))+(((-0.3542)*cj0*gconst11*gconst4))+(((0.3542)*cj0*gconst11*gconst12))+(((0.114)*cj0*gconst12*gconst3*gconst8))+(((-1.136)*gconst10*gconst13*gconst6))+(((-0.3542)*cj0*gconst6*gconst9))+(((-0.114)*cj0*gconst1*gconst10*gconst12))+(((-0.114)*cj0*gconst1*gconst10*gconst13))+(((0.114)*cj0*gconst11*gconst4*gconst8))+(((-0.114)*cj0*gconst1*gconst13*gconst14))+(((0.114)*cj0*gconst11*gconst5*gconst8))+(((0.198816)*gconst11*gconst6))+(((0.120061152)*cj0*gconst14))+(((-0.114)*cj0*gconst14*gconst5*gconst9))+(((-0.114)*cj0*gconst14*gconst5*gconst8))+(((-0.114)*cj0*gconst12*gconst2*gconst9))+(((-1.136)*gconst10*gconst14*gconst5))+(((-1.136)*gconst13*gconst14*gconst2))+(((1.136)*gconst10*gconst15*gconst4))+(((-0.178076352)*gconst9*(cj0*cj0)))+(((-0.114)*cj0*gconst10*gconst5*gconst9))+(((-0.0181944)*gconst13*(cj0*cj0)))+(((-0.0181944)*gconst8*(cj0*cj0)))+(((-0.264)*gconst12*gconst15*gconst3))+(((-0.264)*gconst11*gconst15*gconst4))+(((0.198816)*gconst12*gconst9*(cj0*cj0)))+(((-0.114)*cj0*gconst10*gconst4*gconst9))+(((1.136)*gconst10*gconst12*gconst7))+(((-0.264)*gconst11*gconst7*gconst8))+(((0.3542)*cj0*gconst14*gconst9))+(((-0.264)*gconst11*gconst12*gconst7))+(((-0.114)*cj0*gconst0*gconst13*gconst14))+(((-0.886461248)*gconst12*(cj0*cj0)))+(((-0.114)*cj0*gconst13*gconst2*gconst9))+(((1.136)*gconst12*gconst15*gconst2))+(((-0.198816)*gconst11*gconst14))+(((-0.264)*gconst0*gconst11*gconst15))+(((0.264)*gconst10*gconst7*gconst9))+(((-0.0090972)*gconst1*(cj0*cj0)))+(((-0.09741984)*(cj0*cj0)))+(((0.264)*gconst1*gconst10*gconst15))+(((0.114)*cj0*gconst0*gconst12*gconst15))+(((-0.3542)*cj0*gconst12*gconst3))+(((-1.136)*gconst10*gconst6*gconst9))+(((0.264)*gconst11*gconst13*gconst6))+(((0.158281248)*cj0*gconst11))+(((1.136)*gconst11*gconst6*gconst8))+(((-1.136)*gconst14*gconst2*gconst9))+(((0.264)*gconst13*gconst14*gconst3))+(((0.114)*cj0*gconst13*gconst3*gconst8))+(((0.114)*cj0*gconst12*gconst7*gconst8))+(((0.114)*cj0*gconst12*gconst7*gconst9))+(((-0.198816)*gconst4*gconst9*(cj0*cj0)))+(((1.136)*gconst0*gconst11*gconst14)));
op[4]=((((-0.012996)*gconst12*gconst9*(cj0*cj0)))+(((-1.0)*gconst0*gconst11*gconst12*gconst7))+(((-0.049704)*cj0*gconst3*gconst4))+((gconst1*gconst10*gconst12*gconst7))+(((-0.049704)*cj0*gconst14*gconst9))+(((-0.129504)*cj0*gconst12*gconst2))+(((-0.190096)*gconst11*gconst14))+(((0.1596)*cj0*gconst0*gconst11))+(((0.425036224)*cj0*gconst14))+(((-0.747388)*gconst4*gconst9*(cj0*cj0)))+(((-0.069696)*gconst11*gconst7))+(((-1.0)*gconst1*gconst10*gconst13*gconst6))+(((0.030096)*cj0*gconst7*gconst9))+(((0.030096)*cj0*gconst7*gconst8))+((gconst11*gconst5*gconst6*gconst8))+(((-0.012996)*gconst0*gconst12*(cj0*cj0)))+(((-1.0)*gconst0*gconst12*gconst15*gconst3))+(((0.185476176)*gconst12*(cj0*cj0)))+((gconst0*gconst11*gconst14*gconst5))+(((0.030096)*cj0*gconst0*gconst15))+(((-0.129504)*cj0*gconst0*gconst14))+(((-0.012996)*gconst1*gconst4*(cj0*cj0)))+((gconst12*gconst2*gconst7*gconst9))+(((-1.0)*gconst12*gconst3*gconst7*gconst8))+(((-0.012996)*gconst0*gconst13*(cj0*cj0)))+(((0.16872)*cj0*gconst1*gconst14))+(((0.628112)*gconst11*gconst6))+(((-0.129504)*cj0*gconst13*gconst2))+(((0.1596)*cj0*gconst15*gconst4))+(((-1.0)*gconst10*gconst5*gconst6*gconst9))+(((-1.0)*gconst14*gconst2*gconst5*gconst9))+(((0.092866224)*gconst9*(cj0*cj0)))+(((-0.1596)*cj0*gconst13*gconst6))+(((0.1596)*cj0*gconst3*gconst8))+(((-0.425036224)*cj0*gconst6))+(((-0.012996)*gconst1*gconst13*(cj0*cj0)))+(((-0.1596)*cj0*gconst2*gconst9))+(((-1.0)*gconst13*gconst2*gconst6*gconst9))+(((0.030096)*cj0*gconst11*gconst5))+(((-0.049704)*cj0*gconst11*gconst12))+(((0.32832)*cj0*gconst11*gconst4))+(((0.628112)*gconst14*gconst3))+(((-0.069696)*gconst15*gconst3))+(((-0.012996)*gconst4*gconst8*(cj0*cj0)))+(((-0.220338798144)*(cj0*cj0)))+(((-0.747388)*gconst1*gconst12*(cj0*cj0)))+(((0.1596)*cj0*gconst12*gconst7))+(((-0.129504)*cj0*gconst10*gconst4))+(((-0.129504)*cj0*gconst10*gconst5))+(((-0.1596)*cj0*gconst14*gconst5))+(((-0.070843776)*cj0*gconst3))+(((-1.290496)*gconst14*gconst2))+((gconst15*gconst2*gconst4*gconst9))+((gconst10*gconst4*gconst7*gconst9))+((gconst0*gconst13*gconst14*gconst3))+((gconst0*gconst11*gconst13*gconst6))+(((-0.092866224)*gconst1*(cj0*cj0)))+(((-0.049704)*cj0*gconst1*gconst6))+((gconst1*gconst10*gconst15*gconst4))+(((0.299904)*gconst15*gconst2))+(((0.030096)*cj0*gconst13*gconst3))+(((-1.0)*gconst1*gconst13*gconst14*gconst2))+((gconst14*gconst3*gconst5*gconst8))+(((-0.185476176)*gconst4*(cj0*cj0)))+(((-1.0)*gconst0*gconst11*gconst15*gconst4))+(((-1.290496)*gconst10*gconst6))+(((-0.012996)*gconst5*gconst8*(cj0*cj0)))+((gconst13*gconst3*gconst6*gconst8))+((gconst1*gconst12*gconst15*gconst2))+(((0.030096)*cj0*gconst1*gconst15))+(((-0.190096)*gconst3*gconst6))+(((0.299904)*gconst10*gconst7))+(((0.16872)*cj0*gconst6*gconst9))+(((-0.012996)*gconst5*gconst9*(cj0*cj0)))+(((-0.129504)*cj0*gconst6*gconst8))+(((-0.1596)*cj0*gconst1*gconst10))+(((0.070843776)*cj0*gconst11))+(((-1.0)*gconst1*gconst10*gconst14*gconst5))+(((0.32832)*cj0*gconst12*gconst3))+(((-1.0)*gconst11*gconst4*gconst7*gconst8))+(((-1.0)*gconst15*gconst3*gconst4*gconst8)));
op[5]=((((0.264)*gconst1*gconst10*gconst7))+(((1.136)*gconst3*gconst6*gconst8))+(((-0.264)*gconst3*gconst7*gconst8))+(((-0.1813056)*cj0*gconst2))+(((0.09741984)*(cj0*cj0)))+(((-0.264)*gconst15*gconst3*gconst4))+(((0.120061152)*cj0*gconst6))+(((1.136)*gconst12*gconst2*gconst7))+(((0.114)*cj0*gconst1*gconst12*gconst7))+(((-0.0181944)*gconst0*(cj0*cj0)))+(((-0.3542)*cj0*gconst1*gconst6))+(((0.114)*cj0*gconst3*gconst4*gconst8))+(((-1.136)*gconst2*gconst6*gconst9))+(((1.136)*gconst15*gconst2*gconst4))+(((-0.264)*gconst0*gconst11*gconst7))+(((0.114)*cj0*gconst3*gconst5*gconst8))+(((0.198816)*gconst4*gconst9*(cj0*cj0)))+(((-0.114)*cj0*gconst1*gconst14*gconst5))+(((0.114)*cj0*gconst1*gconst15*gconst4))+(((-1.136)*gconst10*gconst5*gconst6))+(((1.136)*gconst10*gconst4*gconst7))+(((-0.0347928)*cj0*gconst14))+(((-0.0347928)*cj0*gconst11))+(((0.264)*gconst11*gconst5*gconst6))+(((0.114)*cj0*gconst0*gconst15*gconst4))+(((-0.0090972)*gconst12*(cj0*cj0)))+(((-0.114)*cj0*gconst1*gconst10*gconst4))+(((-0.114)*cj0*gconst1*gconst10*gconst5))+(((1.136)*gconst0*gconst11*gconst6))+(((-0.114)*cj0*gconst1*gconst13*gconst2))+(((-0.114)*cj0*gconst1*gconst13*gconst6))+(((0.264)*gconst2*gconst7*gconst9))+(((-0.114)*cj0*gconst0*gconst13*gconst6))+(((-0.178076352)*gconst1*(cj0*cj0)))+(((0.264)*gconst13*gconst3*gconst6))+(((-0.114)*cj0*gconst2*gconst5*gconst9))+(((-1.136)*gconst1*gconst14*gconst2))+(((0.3542)*cj0*gconst12*gconst3))+(((-0.0181944)*gconst5*(cj0*cj0)))+(((-0.114)*cj0*gconst5*gconst6*gconst9))+(((-0.114)*cj0*gconst5*gconst6*gconst8))+(((1.136)*gconst0*gconst14*gconst3))+(((-1.136)*gconst13*gconst2*gconst6))+(((0.264)*gconst1*gconst15*gconst2))+(((0.198816)*gconst1*gconst12*(cj0*cj0)))+(((-0.114)*cj0*gconst1*gconst12*gconst2))+(((-0.886461248)*gconst4*(cj0*cj0)))+(((0.114)*cj0*gconst0*gconst12*gconst7))+(((0.114)*cj0*gconst0*gconst12*gconst3))+(((-0.198816)*gconst1*gconst4*(cj0*cj0)))+(((0.198816)*gconst3*gconst6))+(((-0.114)*cj0*gconst2*gconst4*gconst9))+(((-0.264)*gconst12*gconst3*gconst7))+(((0.0421344)*cj0*gconst7))+(((0.3542)*cj0*gconst11*gconst4))+(((0.158281248)*cj0*gconst3))+(((-0.264)*gconst0*gconst15*gconst3))+(((0.3542)*cj0*gconst1*gconst14))+(((-0.3542)*cj0*gconst3*gconst4))+(((-0.198816)*gconst11*gconst6))+(((0.3542)*cj0*gconst6*gconst9))+(((-0.114)*cj0*gconst0*gconst14*gconst5))+(((-0.264)*gconst11*gconst4*gconst7))+(((-1.136)*gconst14*gconst2*gconst5))+(((-1.136)*gconst1*gconst10*gconst6))+(((-0.198816)*gconst14*gconst3))+(((-0.0090972)*gconst9*(cj0*cj0)))+(((0.114)*cj0*gconst4*gconst7*gconst9))+(((0.114)*cj0*gconst4*gconst7*gconst8))+(((0.114)*cj0*gconst0*gconst11*gconst4))+(((0.114)*cj0*gconst0*gconst11*gconst5))+(((0.114)*cj0*gconst0*gconst13*gconst3))+(((0.264)*gconst14*gconst3*gconst5)));
op[6]=((((0.185476176)*gconst4*x160))+(((-1.0)*x165*x207))+(((-1.0)*gconst7*x164*x177))+(((-1.0)*gconst3*x177*x178))+(((0.32832)*gconst3*x163))+(((-1.0)*gconst15*x177*x208))+(((-1.0)*gconst0*gconst4*x217))+(((-1.0)*x166*x218))+((x162*x185))+((x162*x187))+(((-1.0)*x163*x172))+(((-1.0)*x189*x198))+((gconst15*gconst4*x198))+(((0.1596)*gconst7*x163))+((gconst1*x222))+(((-1.0)*x183*x217))+(((0.628112)*x186))+(((0.16872)*gconst1*x167))+(((-1.0)*gconst6*x192*x198))+(((0.1596)*gconst0*x170))+(((-1.0)*cj0*gconst5*x172))+(((-1.0)*x181*x219))+((x191*x201))+((x162*x203))+((x164*x165))+((gconst0*gconst13*x186))+(((-0.747388)*x160*x209))+((x194*x195))+((x171*x185))+(((-0.069696)*gconst3*gconst7))+(((-0.129504)*gconst0*x167))+(((-1.0)*x165*x189))+(((0.299904)*x195))+(((-1.0)*x212*x217))+(((0.070843776)*x170))+(((-1.0)*x165*x191))+((gconst3*gconst8*x165))+(((0.425036224)*x167))+(((-1.0)*x229))+(((-1.290496)*gconst2*gconst6))+((x195*x210)));
op[7]=((((-1.0)*x180*x201))+(((1.136)*gconst4*x195))+(((-1.0)*gconst0*x165*x175))+(((-1.0)*gconst1*x221))+(((-0.114)*x163*x198))+(((0.3542)*gconst1*x167))+(((1.136)*gconst0*x186))+(((-1.136)*gconst2*x165))+(((0.114)*x163*x208))+(((0.114)*x163*x203))+(((0.264)*gconst1*x195))+(((-1.0)*gconst4*x221))+(((-1.0)*x180*x187))+(((0.3542)*gconst3*x163))+(((-1.0)*gconst2*x175*x183))+((x165*x180))+(((-0.198816)*x186))+(((-0.0347928)*x167))+(((0.198816)*x160*x209))+(((-1.136)*gconst6*x198))+(((-1.0)*gconst1*x165*x175))+(((-0.0347928)*x170))+(((0.114)*x163*x187))+(((0.114)*x170*x212)));
op[8]=(((x165*x208))+(((-0.049704)*gconst3*x163))+(((-1.0)*x177*x218))+((x195*x209))+(((-0.190096)*x186))+(((-1.0)*x209*x217))+(((-1.0)*x165*x219))+(((-1.0)*x167*x179)));
polyroots8(op,zeror,numroots);
IkReal j1array[8], cj1array[8], sj1array[8], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[8]={true,true,true,true,true,true,true,true};
_nj1 = 8;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2eval[2];
j2eval[0]=cj0;
j2eval[1]=IKsign(cj0);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=sj0;
j2eval[1]=IKsign(sj0);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j0))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x230=(sj1*sj4);
IkReal x231=(cj5*r01);
IkReal x232=((0.0808303625942922)*sj5);
IkReal x233=(cj1*sj4);
IkReal x234=((0.309140685009749)*sj5);
IkReal x235=(cj5*r21);
IkReal x236=(cj4*r02);
IkReal x237=(pz*sj1);
IkReal x238=((1.12264392492073)*px);
IkReal x239=((0.0808303625942922)*sj1);
IkReal x240=((4.29362062513541)*cj1);
IkReal x241=(cj4*r22);
IkReal x242=((0.0808303625942922)*cj1);
IkReal x243=((0.309140685009749)*x241);
if( IKabs(((0.392925373722254)+(((-0.309140685009749)*x230*x231))+(((-1.0)*pz*x240))+((cj1*x238))+(((-1.0)*r20*x233*x234))+(((-1.0)*r00*x230*x234))+(((-1.0)*r20*x230*x232))+(((-0.0808303625942922)*x230*x235))+(((0.0808303625942922)*x231*x233))+(((0.309140685009749)*sj1*x236))+((r00*x232*x233))+((cj1*x243))+(((-1.0)*x236*x242))+(((-1.12264392492073)*x237))+((x239*x241))+(((-4.29362062513541)*px*sj1))+(((-0.309140685009749)*x233*x235)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((1.50276721879739)+(((-0.309140685009749)*x230*x235))+(((1.12264392492073)*cj1*pz))+((px*x240))+((sj1*x238))+(((-0.309140685009749)*cj1*x236))+(((-1.0)*r20*x230*x234))+(((-4.29362062513541)*x237))+((r00*x233*x234))+(((-1.0)*x241*x242))+((r00*x230*x232))+(((-1.0)*x236*x239))+(((0.0808303625942922)*x230*x231))+(((0.0808303625942922)*x233*x235))+((sj1*x243))+((r20*x232*x233))+(((0.309140685009749)*x231*x233)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.392925373722254)+(((-0.309140685009749)*x230*x231))+(((-1.0)*pz*x240))+((cj1*x238))+(((-1.0)*r20*x233*x234))+(((-1.0)*r00*x230*x234))+(((-1.0)*r20*x230*x232))+(((-0.0808303625942922)*x230*x235))+(((0.0808303625942922)*x231*x233))+(((0.309140685009749)*sj1*x236))+((r00*x232*x233))+((cj1*x243))+(((-1.0)*x236*x242))+(((-1.12264392492073)*x237))+((x239*x241))+(((-4.29362062513541)*px*sj1))+(((-0.309140685009749)*x233*x235))))+IKsqr(((1.50276721879739)+(((-0.309140685009749)*x230*x235))+(((1.12264392492073)*cj1*pz))+((px*x240))+((sj1*x238))+(((-0.309140685009749)*cj1*x236))+(((-1.0)*r20*x230*x234))+(((-4.29362062513541)*x237))+((r00*x233*x234))+(((-1.0)*x241*x242))+((r00*x230*x232))+(((-1.0)*x236*x239))+(((0.0808303625942922)*x230*x231))+(((0.0808303625942922)*x233*x235))+((sj1*x243))+((r20*x232*x233))+(((0.309140685009749)*x231*x233))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((0.392925373722254)+(((-0.309140685009749)*x230*x231))+(((-1.0)*pz*x240))+((cj1*x238))+(((-1.0)*r20*x233*x234))+(((-1.0)*r00*x230*x234))+(((-1.0)*r20*x230*x232))+(((-0.0808303625942922)*x230*x235))+(((0.0808303625942922)*x231*x233))+(((0.309140685009749)*sj1*x236))+((r00*x232*x233))+((cj1*x243))+(((-1.0)*x236*x242))+(((-1.12264392492073)*x237))+((x239*x241))+(((-4.29362062513541)*px*sj1))+(((-0.309140685009749)*x233*x235))), ((1.50276721879739)+(((-0.309140685009749)*x230*x235))+(((1.12264392492073)*cj1*pz))+((px*x240))+((sj1*x238))+(((-0.309140685009749)*cj1*x236))+(((-1.0)*r20*x230*x234))+(((-4.29362062513541)*x237))+((r00*x233*x234))+(((-1.0)*x241*x242))+((r00*x230*x232))+(((-1.0)*x236*x239))+(((0.0808303625942922)*x230*x231))+(((0.0808303625942922)*x233*x235))+((sj1*x243))+((r20*x232*x233))+(((0.309140685009749)*x231*x233))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[2];
IkReal x244=IKcos(j2);
IkReal x245=IKsin(j2);
IkReal x246=((0.218)*sj1);
IkReal x247=((0.072)*sj4);
IkReal x248=((0.072)*cj4);
IkReal x249=((0.218)*cj1);
IkReal x250=((0.057)*x245);
IkReal x251=((0.057)*x244);
evalcond[0]=(((cj1*x251))+(((-1.0)*r20*sj5*x247))+(((-1.0)*cj5*r21*x247))+((r22*x248))+(((0.35)*sj1))+(((-1.0)*pz))+(((-1.0)*sj1*x250))+(((-1.0)*x245*x249))+(((-1.0)*x244*x246)));
evalcond[1]=((((-0.35)*cj1))+((cj1*x250))+((r02*x248))+(((-1.0)*r00*sj5*x247))+((sj1*x251))+((x244*x249))+(((-1.0)*cj5*r01*x247))+(((-1.0)*px))+(((-1.0)*x245*x246)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[2];
sj0=0;
cj0=1.0;
j0=0;
IkReal x252=(((cj4*r00*sj5))+((r02*sj4))+((cj4*cj5*r01)));
j3eval[0]=x252;
j3eval[1]=IKsign(x252);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj0=0;
cj0=1.0;
j0=0;
IkReal x253=cj4*cj4;
IkReal x254=cj5*cj5;
IkReal x255=(r00*r10);
IkReal x256=(cj4*sj4);
IkReal x257=(r10*sj5);
IkReal x258=(r01*r11);
IkReal x259=(cj5*r01);
IkReal x260=(cj5*r11);
IkReal x261=(r00*sj5);
IkReal x262=((1.0)*x253);
IkReal x263=(((r12*x256*x259))+((x253*x260*x261))+((x253*x254*x258))+((r12*x256*x261))+((x253*x255))+((r02*x256*x257))+((r02*x256*x260))+(((-1.0)*r02*r12*x262))+((x253*x257*x259))+(((-1.0)*x255))+(((-1.0)*x258))+(((-1.0)*x254*x255*x262)));
j3eval[0]=x263;
j3eval[1]=IKsign(x263);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
continue; // 1 cases reached

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x264=cj4*cj4;
IkReal x265=cj5*cj5;
IkReal x266=(r10*sj5);
IkReal x267=(cj4*sj4);
IkReal x268=((1.0)*r11);
IkReal x269=(r00*r10);
IkReal x270=(cj4*r12);
IkReal x271=(cj2*sj1);
IkReal x272=(r00*sj5);
IkReal x273=(cj1*sj2);
IkReal x274=(cj5*r01);
IkReal x275=((1.0)*sj4);
IkReal x276=(cj5*x273);
IkReal x277=((1.0)*x264);
IkReal x278=(r11*x264);
CheckValue<IkReal> x279=IKPowWithIntegerCheck(IKsign((((r12*x267*x274))+((r12*x267*x272))+(((-1.0)*x265*x269*x277))+(((-1.0)*x269))+((r02*x266*x267))+((cj5*x272*x278))+((x264*x266*x274))+((cj5*r02*r11*x267))+((x264*x269))+(((-1.0)*r02*r12*x277))+(((-1.0)*r01*x268))+((r01*x265*x278)))),-1);
if(!x279.valid){
continue;
}
CheckValue<IkReal> x280 = IKatan2WithCheck(IkReal(((((-1.0)*x266*x271*x275))+(((-1.0)*x266*x273*x275))+(((-1.0)*sj4*x268*x276))+((x270*x271))+((x270*x273))+(((-1.0)*cj5*sj4*x268*x271)))),IkReal((((cj5*r10*x271))+(((-1.0)*sj5*x268*x273))+(((-1.0)*sj5*x268*x271))+((r10*x276)))),IKFAST_ATAN2_MAGTHRESH);
if(!x280.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x279.value)))+(x280.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x281=IKcos(j3);
IkReal x282=IKsin(j3);
IkReal x283=((1.0)*cj5);
IkReal x284=(sj4*sj5);
IkReal x285=(sj1*sj2);
IkReal x286=((1.0)*cj2);
IkReal x287=(cj5*sj4);
IkReal x288=((1.0)*cj1*sj2);
IkReal x289=(sj1*x286);
IkReal x290=(r20*x281);
IkReal x291=(r10*x282);
IkReal x292=(r20*x282);
IkReal x293=(r10*x281);
IkReal x294=(r01*x281);
IkReal x295=(r00*x282);
IkReal x296=(r11*x281);
IkReal x297=(r00*x281);
IkReal x298=(r21*x281);
IkReal x299=((1.0)*cj4*x282);
IkReal x300=((1.0)*cj4*x281);
IkReal x301=((1.0)*sj5*x282);
IkReal x302=(x289+x288);
evalcond[0]=(((cj5*x291))+((x287*x296))+((x284*x293))+(((-1.0)*r11*x301))+(((-1.0)*r12*x300)));
evalcond[1]=(((sj5*x296))+((x284*x291))+((r11*x282*x287))+(((-1.0)*x283*x293))+(((-1.0)*r12*x299)));
evalcond[2]=(((sj5*x298))+((x284*x292))+x285+(((-1.0)*cj1*x286))+(((-1.0)*x283*x290))+(((-1.0)*r22*x299))+((r21*x282*x287)));
evalcond[3]=((((-1.0)*r01*x301))+((cj5*x295))+((x287*x294))+((x284*x297))+(((-1.0)*r02*x300))+(((-1.0)*x285))+((cj1*cj2)));
evalcond[4]=((((-1.0)*r22*x300))+(((-1.0)*r21*x301))+((cj5*x292))+((x287*x298))+((x284*x290))+(((-1.0)*x302)));
evalcond[5]=(((sj5*x294))+((r01*x282*x287))+((x284*x295))+(((-1.0)*r02*x299))+(((-1.0)*x283*x297))+(((-1.0)*x302)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x303=(cj1*cj2);
IkReal x304=(cj5*r10);
IkReal x305=(cj4*r12);
IkReal x306=((1.0)*sj4);
IkReal x307=(sj1*sj2);
IkReal x308=(r10*sj5);
IkReal x309=(r11*x307);
CheckValue<IkReal> x310=IKPowWithIntegerCheck(IKsign((((cj4*r00*sj5))+((r02*sj4))+((cj4*cj5*r01)))),-1);
if(!x310.valid){
continue;
}
CheckValue<IkReal> x311 = IKatan2WithCheck(IkReal((((sj5*x309))+((x303*x304))+(((-1.0)*x304*x307))+(((-1.0)*r11*sj5*x303)))),IkReal(((((-1.0)*x303*x305))+(((-1.0)*cj5*x306*x309))+((x305*x307))+((cj5*r11*sj4*x303))+(((-1.0)*x306*x307*x308))+((sj4*x303*x308)))),IKFAST_ATAN2_MAGTHRESH);
if(!x311.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x310.value)))+(x311.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x312=IKcos(j3);
IkReal x313=IKsin(j3);
IkReal x314=((1.0)*cj5);
IkReal x315=(sj4*sj5);
IkReal x316=(sj1*sj2);
IkReal x317=((1.0)*cj2);
IkReal x318=(cj5*sj4);
IkReal x319=((1.0)*cj1*sj2);
IkReal x320=(sj1*x317);
IkReal x321=(r20*x312);
IkReal x322=(r10*x313);
IkReal x323=(r20*x313);
IkReal x324=(r10*x312);
IkReal x325=(r01*x312);
IkReal x326=(r00*x313);
IkReal x327=(r11*x312);
IkReal x328=(r00*x312);
IkReal x329=(r21*x312);
IkReal x330=((1.0)*cj4*x313);
IkReal x331=((1.0)*cj4*x312);
IkReal x332=((1.0)*sj5*x313);
IkReal x333=(x320+x319);
evalcond[0]=(((x318*x327))+((cj5*x322))+(((-1.0)*r11*x332))+((x315*x324))+(((-1.0)*r12*x331)));
evalcond[1]=((((-1.0)*x314*x324))+((sj5*x327))+((x315*x322))+(((-1.0)*r12*x330))+((r11*x313*x318)));
evalcond[2]=((((-1.0)*x314*x321))+((r21*x313*x318))+((sj5*x329))+x316+(((-1.0)*cj1*x317))+((x315*x323))+(((-1.0)*r22*x330)));
evalcond[3]=(((x318*x325))+(((-1.0)*r01*x332))+((cj5*x326))+(((-1.0)*r02*x331))+((x315*x328))+((cj1*cj2))+(((-1.0)*x316)));
evalcond[4]=(((x318*x329))+(((-1.0)*r21*x332))+((cj5*x323))+((x315*x321))+(((-1.0)*x333))+(((-1.0)*r22*x331)));
evalcond[5]=((((-1.0)*x314*x328))+((sj5*x325))+(((-1.0)*r02*x330))+((x315*x326))+((r01*x313*x318))+(((-1.0)*x333)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x334=(sj1*sj4);
IkReal x335=(cj5*r01);
IkReal x336=((0.0808303625942922)*sj5);
IkReal x337=(cj1*sj4);
IkReal x338=((0.309140685009749)*sj5);
IkReal x339=(cj5*r21);
IkReal x340=(cj4*r02);
IkReal x341=(pz*sj1);
IkReal x342=((1.12264392492073)*px);
IkReal x343=((0.0808303625942922)*sj1);
IkReal x344=((4.29362062513541)*cj1);
IkReal x345=(cj4*r22);
IkReal x346=((0.0808303625942922)*cj1);
IkReal x347=((0.309140685009749)*x345);
if( IKabs(((0.392925373722254)+(((-1.0)*r00*x336*x337))+(((-1.0)*cj1*x342))+(((4.29362062513541)*px*sj1))+(((-1.0)*r20*x334*x336))+(((-0.309140685009749)*x337*x339))+(((-0.309140685009749)*sj1*x340))+((cj1*x347))+(((-0.0808303625942922)*x334*x339))+((r00*x334*x338))+(((-1.0)*r20*x337*x338))+(((-0.0808303625942922)*x335*x337))+(((-1.12264392492073)*x341))+(((0.309140685009749)*x334*x335))+((x340*x346))+((x343*x345))+(((-1.0)*pz*x344)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((1.50276721879739)+(((1.12264392492073)*cj1*pz))+(((-1.0)*px*x344))+(((-1.0)*r00*x337*x338))+(((-1.0)*r20*x334*x338))+(((-0.309140685009749)*x334*x339))+(((0.0808303625942922)*x337*x339))+((r20*x336*x337))+(((-0.0808303625942922)*x334*x335))+(((-0.309140685009749)*x335*x337))+(((-1.0)*x345*x346))+((sj1*x347))+(((0.309140685009749)*cj1*x340))+(((-1.0)*r00*x334*x336))+((x340*x343))+(((-4.29362062513541)*x341))+(((-1.0)*sj1*x342)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.392925373722254)+(((-1.0)*r00*x336*x337))+(((-1.0)*cj1*x342))+(((4.29362062513541)*px*sj1))+(((-1.0)*r20*x334*x336))+(((-0.309140685009749)*x337*x339))+(((-0.309140685009749)*sj1*x340))+((cj1*x347))+(((-0.0808303625942922)*x334*x339))+((r00*x334*x338))+(((-1.0)*r20*x337*x338))+(((-0.0808303625942922)*x335*x337))+(((-1.12264392492073)*x341))+(((0.309140685009749)*x334*x335))+((x340*x346))+((x343*x345))+(((-1.0)*pz*x344))))+IKsqr(((1.50276721879739)+(((1.12264392492073)*cj1*pz))+(((-1.0)*px*x344))+(((-1.0)*r00*x337*x338))+(((-1.0)*r20*x334*x338))+(((-0.309140685009749)*x334*x339))+(((0.0808303625942922)*x337*x339))+((r20*x336*x337))+(((-0.0808303625942922)*x334*x335))+(((-0.309140685009749)*x335*x337))+(((-1.0)*x345*x346))+((sj1*x347))+(((0.309140685009749)*cj1*x340))+(((-1.0)*r00*x334*x336))+((x340*x343))+(((-4.29362062513541)*x341))+(((-1.0)*sj1*x342))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((0.392925373722254)+(((-1.0)*r00*x336*x337))+(((-1.0)*cj1*x342))+(((4.29362062513541)*px*sj1))+(((-1.0)*r20*x334*x336))+(((-0.309140685009749)*x337*x339))+(((-0.309140685009749)*sj1*x340))+((cj1*x347))+(((-0.0808303625942922)*x334*x339))+((r00*x334*x338))+(((-1.0)*r20*x337*x338))+(((-0.0808303625942922)*x335*x337))+(((-1.12264392492073)*x341))+(((0.309140685009749)*x334*x335))+((x340*x346))+((x343*x345))+(((-1.0)*pz*x344))), ((1.50276721879739)+(((1.12264392492073)*cj1*pz))+(((-1.0)*px*x344))+(((-1.0)*r00*x337*x338))+(((-1.0)*r20*x334*x338))+(((-0.309140685009749)*x334*x339))+(((0.0808303625942922)*x337*x339))+((r20*x336*x337))+(((-0.0808303625942922)*x334*x335))+(((-0.309140685009749)*x335*x337))+(((-1.0)*x345*x346))+((sj1*x347))+(((0.309140685009749)*cj1*x340))+(((-1.0)*r00*x334*x336))+((x340*x343))+(((-4.29362062513541)*x341))+(((-1.0)*sj1*x342))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[2];
IkReal x348=IKcos(j2);
IkReal x349=IKsin(j2);
IkReal x350=((0.218)*sj1);
IkReal x351=((0.072)*sj4);
IkReal x352=((0.072)*cj4);
IkReal x353=((0.218)*cj1);
IkReal x354=((0.057)*x349);
IkReal x355=((0.057)*x348);
evalcond[0]=(((cj1*x355))+(((-1.0)*cj5*r21*x351))+(((-1.0)*x348*x350))+(((-1.0)*x349*x353))+(((0.35)*sj1))+(((-1.0)*pz))+(((-1.0)*r20*sj5*x351))+((r22*x352))+(((-1.0)*sj1*x354)));
evalcond[1]=((((-1.0)*x348*x353))+(((-1.0)*cj1*x354))+(((-1.0)*px))+((x349*x350))+(((-1.0)*r00*sj5*x351))+(((-1.0)*cj5*r01*x351))+((r02*x352))+(((-1.0)*sj1*x355))+(((0.35)*cj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[2];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x356=(((cj4*r00*sj5))+((r02*sj4))+((cj4*cj5*r01)));
j3eval[0]=x356;
j3eval[1]=IKsign(x356);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x357=cj4*cj4;
IkReal x358=cj5*cj5;
IkReal x359=(r00*r10);
IkReal x360=(cj4*sj4);
IkReal x361=(r10*sj5);
IkReal x362=(r01*r11);
IkReal x363=(cj5*r01);
IkReal x364=(cj5*r11);
IkReal x365=(r00*sj5);
IkReal x366=((1.0)*x357);
IkReal x367=((((-1.0)*x362))+(((-1.0)*x358*x359*x366))+((x357*x361*x363))+(((-1.0)*x359))+((r02*x360*x364))+((r02*x360*x361))+((x357*x364*x365))+((r12*x360*x363))+((r12*x360*x365))+((x357*x359))+(((-1.0)*r02*r12*x366))+((x357*x358*x362)));
j3eval[0]=x367;
j3eval[1]=IKsign(x367);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
continue; // 1 cases reached

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x368=cj4*cj4;
IkReal x369=cj5*cj5;
IkReal x370=(cj4*r02);
IkReal x371=((1.0)*r12);
IkReal x372=(cj2*sj1);
IkReal x373=(r01*r11);
IkReal x374=(cj5*r11);
IkReal x375=(cj1*sj2);
IkReal x376=(cj5*r01);
IkReal x377=(r11*sj5);
IkReal x378=(r10*sj4*sj5);
IkReal x379=((1.0)*r00*r10);
IkReal x380=(sj5*x368);
IkReal x381=(cj4*r12*sj4);
IkReal x382=((1.0)*cj5*r10);
IkReal x383=(x368*x369);
CheckValue<IkReal> x384 = IKatan2WithCheck(IkReal((((x375*x378))+((sj4*x374*x375))+((sj4*x372*x374))+((x372*x378))+(((-1.0)*cj4*x371*x372))+(((-1.0)*cj4*x371*x375)))),IkReal((((x375*x377))+(((-1.0)*x375*x382))+((x372*x377))+(((-1.0)*x372*x382)))),IKFAST_ATAN2_MAGTHRESH);
if(!x384.valid){
continue;
}
CheckValue<IkReal> x385=IKPowWithIntegerCheck(IKsign(((((-1.0)*x373))+((x370*x378))+((x376*x381))+((sj4*x370*x374))+((x373*x383))+(((-1.0)*x379*x383))+(((-1.0)*x379))+(((-1.0)*r02*x368*x371))+((r00*r10*x368))+((r00*x374*x380))+((r10*x376*x380))+((r00*sj5*x381)))),-1);
if(!x385.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x384.value)+(((1.5707963267949)*(x385.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x386=IKcos(j3);
IkReal x387=IKsin(j3);
IkReal x388=(sj1*sj2);
IkReal x389=((1.0)*cj5);
IkReal x390=(sj4*sj5);
IkReal x391=((1.0)*cj4);
IkReal x392=((1.0)*cj2);
IkReal x393=(cj1*sj2);
IkReal x394=(r01*sj4);
IkReal x395=(r21*sj4);
IkReal x396=(r11*sj4);
IkReal x397=(cj1*x392);
IkReal x398=(r20*x386);
IkReal x399=(r10*x387);
IkReal x400=(r20*x387);
IkReal x401=(r10*x386);
IkReal x402=(cj5*x387);
IkReal x403=(cj5*x386);
IkReal x404=(sj5*x386);
IkReal x405=(r00*x386);
IkReal x406=((1.0)*sj5*x387);
evalcond[0]=(((x390*x401))+((cj5*x399))+(((-1.0)*r11*x406))+(((-1.0)*r12*x386*x391))+((x396*x403)));
evalcond[1]=(((r11*x404))+(((-1.0)*r12*x387*x391))+(((-1.0)*x389*x401))+((x390*x399))+((x396*x402)));
evalcond[2]=(((cj2*sj1))+((r00*x387*x390))+x393+((r01*x404))+(((-1.0)*x389*x405))+((x394*x402))+(((-1.0)*r02*x387*x391)));
evalcond[3]=((((-1.0)*x397))+((x390*x400))+(((-1.0)*x389*x398))+x388+((r21*x404))+((x395*x402))+(((-1.0)*r22*x387*x391)));
evalcond[4]=((((-1.0)*r02*x386*x391))+(((-1.0)*x397))+((x390*x405))+x388+((r00*x402))+((x394*x403))+(((-1.0)*r01*x406)));
evalcond[5]=((((-1.0)*r22*x386*x391))+(((-1.0)*x393))+(((-1.0)*sj1*x392))+(((-1.0)*r21*x406))+((cj5*x400))+((x395*x403))+((x390*x398)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x407=(cj1*cj2);
IkReal x408=(cj5*r10);
IkReal x409=(cj4*r12);
IkReal x410=((1.0)*sj4);
IkReal x411=(sj1*sj2);
IkReal x412=(r10*sj5);
IkReal x413=(r11*x411);
CheckValue<IkReal> x414=IKPowWithIntegerCheck(IKsign((((cj4*r00*sj5))+((r02*sj4))+((cj4*cj5*r01)))),-1);
if(!x414.valid){
continue;
}
CheckValue<IkReal> x415 = IKatan2WithCheck(IkReal((((x407*x408))+((sj5*x413))+(((-1.0)*x408*x411))+(((-1.0)*r11*sj5*x407)))),IkReal((((x409*x411))+(((-1.0)*x410*x411*x412))+((cj5*r11*sj4*x407))+(((-1.0)*cj5*x410*x413))+((sj4*x407*x412))+(((-1.0)*x407*x409)))),IKFAST_ATAN2_MAGTHRESH);
if(!x415.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x414.value)))+(x415.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x416=IKcos(j3);
IkReal x417=IKsin(j3);
IkReal x418=(sj1*sj2);
IkReal x419=((1.0)*cj5);
IkReal x420=(sj4*sj5);
IkReal x421=((1.0)*cj4);
IkReal x422=((1.0)*cj2);
IkReal x423=(cj1*sj2);
IkReal x424=(r01*sj4);
IkReal x425=(r21*sj4);
IkReal x426=(r11*sj4);
IkReal x427=(cj1*x422);
IkReal x428=(r20*x416);
IkReal x429=(r10*x417);
IkReal x430=(r20*x417);
IkReal x431=(r10*x416);
IkReal x432=(cj5*x417);
IkReal x433=(cj5*x416);
IkReal x434=(sj5*x416);
IkReal x435=(r00*x416);
IkReal x436=((1.0)*sj5*x417);
evalcond[0]=(((x426*x433))+(((-1.0)*r11*x436))+((cj5*x429))+((x420*x431))+(((-1.0)*r12*x416*x421)));
evalcond[1]=(((x420*x429))+((x426*x432))+(((-1.0)*r12*x417*x421))+((r11*x434))+(((-1.0)*x419*x431)));
evalcond[2]=(((r00*x417*x420))+((cj2*sj1))+((x424*x432))+x423+((r01*x434))+(((-1.0)*r02*x417*x421))+(((-1.0)*x419*x435)));
evalcond[3]=((((-1.0)*r22*x417*x421))+(((-1.0)*x427))+((x425*x432))+((r21*x434))+x418+(((-1.0)*x419*x428))+((x420*x430)));
evalcond[4]=(((x424*x433))+(((-1.0)*x427))+(((-1.0)*r02*x416*x421))+x418+((r00*x432))+(((-1.0)*r01*x436))+((x420*x435)));
evalcond[5]=(((x420*x428))+(((-1.0)*x423))+(((-1.0)*sj1*x422))+((cj5*x430))+((x425*x433))+(((-1.0)*r22*x416*x421))+(((-1.0)*r21*x436)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x437=(cj1*sj4);
IkReal x438=(cj5*r11);
IkReal x439=((0.309140685009749)*sj5);
IkReal x440=((0.309140685009749)*sj1);
IkReal x441=(cj5*r21);
IkReal x442=(cj4*r22);
IkReal x443=(pz*sj1);
IkReal x444=(sj1*sj4);
IkReal x445=((0.0808303625942922)*sj5);
IkReal x446=((0.0808303625942922)*cj1);
IkReal x447=((4.29362062513541)*cj1);
IkReal x448=(cj4*r12);
IkReal x449=((0.0808303625942922)*sj1);
IkReal x450=((0.309140685009749)*cj1);
IkReal x451=((1.12264392492073)*cj1);
IkReal x452=(py*sj1);
if( IKabs(((0.392925373722254)+(((-1.12264392492073)*x443))+(((-4.29362062513541)*x452))+((r10*x437*x445))+(((-1.0)*r20*x437*x439))+((x440*x448))+(((-0.309140685009749)*x437*x441))+((x442*x450))+(((-1.0)*sj4*x438*x440))+((x442*x449))+(((-1.0)*pz*x447))+((py*x451))+(((-1.0)*r20*x444*x445))+(((0.0808303625942922)*x437*x438))+(((-1.0)*x446*x448))+(((-0.0808303625942922)*x441*x444))+(((-1.0)*r10*x439*x444)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((1.50276721879739)+(((0.0808303625942922)*x438*x444))+(((-1.0)*r20*x439*x444))+(((-1.0)*sj4*x440*x441))+((r10*x437*x439))+((py*x447))+((x440*x442))+(((1.12264392492073)*x452))+(((-1.0)*x448*x449))+(((-4.29362062513541)*x443))+((r20*x437*x445))+(((0.309140685009749)*x437*x438))+((pz*x451))+((r10*x444*x445))+(((0.0808303625942922)*x437*x441))+(((-1.0)*x448*x450))+(((-1.0)*x442*x446)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.392925373722254)+(((-1.12264392492073)*x443))+(((-4.29362062513541)*x452))+((r10*x437*x445))+(((-1.0)*r20*x437*x439))+((x440*x448))+(((-0.309140685009749)*x437*x441))+((x442*x450))+(((-1.0)*sj4*x438*x440))+((x442*x449))+(((-1.0)*pz*x447))+((py*x451))+(((-1.0)*r20*x444*x445))+(((0.0808303625942922)*x437*x438))+(((-1.0)*x446*x448))+(((-0.0808303625942922)*x441*x444))+(((-1.0)*r10*x439*x444))))+IKsqr(((1.50276721879739)+(((0.0808303625942922)*x438*x444))+(((-1.0)*r20*x439*x444))+(((-1.0)*sj4*x440*x441))+((r10*x437*x439))+((py*x447))+((x440*x442))+(((1.12264392492073)*x452))+(((-1.0)*x448*x449))+(((-4.29362062513541)*x443))+((r20*x437*x445))+(((0.309140685009749)*x437*x438))+((pz*x451))+((r10*x444*x445))+(((0.0808303625942922)*x437*x441))+(((-1.0)*x448*x450))+(((-1.0)*x442*x446))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((0.392925373722254)+(((-1.12264392492073)*x443))+(((-4.29362062513541)*x452))+((r10*x437*x445))+(((-1.0)*r20*x437*x439))+((x440*x448))+(((-0.309140685009749)*x437*x441))+((x442*x450))+(((-1.0)*sj4*x438*x440))+((x442*x449))+(((-1.0)*pz*x447))+((py*x451))+(((-1.0)*r20*x444*x445))+(((0.0808303625942922)*x437*x438))+(((-1.0)*x446*x448))+(((-0.0808303625942922)*x441*x444))+(((-1.0)*r10*x439*x444))), ((1.50276721879739)+(((0.0808303625942922)*x438*x444))+(((-1.0)*r20*x439*x444))+(((-1.0)*sj4*x440*x441))+((r10*x437*x439))+((py*x447))+((x440*x442))+(((1.12264392492073)*x452))+(((-1.0)*x448*x449))+(((-4.29362062513541)*x443))+((r20*x437*x445))+(((0.309140685009749)*x437*x438))+((pz*x451))+((r10*x444*x445))+(((0.0808303625942922)*x437*x441))+(((-1.0)*x448*x450))+(((-1.0)*x442*x446))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[2];
IkReal x453=IKcos(j2);
IkReal x454=IKsin(j2);
IkReal x455=((0.072)*sj4);
IkReal x456=((0.072)*cj4);
IkReal x457=((0.057)*x454);
IkReal x458=((0.218)*x453);
IkReal x459=((0.218)*x454);
IkReal x460=((0.057)*x453);
evalcond[0]=((((-1.0)*cj5*r21*x455))+((cj1*x460))+(((-1.0)*r20*sj5*x455))+(((0.35)*sj1))+(((-1.0)*cj1*x459))+(((-1.0)*pz))+(((-1.0)*sj1*x457))+(((-1.0)*sj1*x458))+((r22*x456)));
evalcond[1]=((((-1.0)*cj5*r11*x455))+(((-0.35)*cj1))+(((-1.0)*r10*sj5*x455))+((cj1*x458))+((cj1*x457))+(((-1.0)*py))+(((-1.0)*sj1*x459))+((r12*x456))+((sj1*x460)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[2];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x461=((1.0)*cj4);
IkReal x462=((((-1.0)*cj5*r11*x461))+(((-1.0)*r10*sj5*x461))+(((-1.0)*r12*sj4)));
j3eval[0]=x462;
j3eval[1]=IKsign(x462);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x463=cj4*cj4;
IkReal x464=cj5*cj5;
IkReal x465=(r00*r10);
IkReal x466=(cj4*sj4);
IkReal x467=(r10*sj5);
IkReal x468=(r01*r11);
IkReal x469=(cj5*r01);
IkReal x470=(cj5*r11);
IkReal x471=(r00*sj5);
IkReal x472=((1.0)*x463);
IkReal x473=(((x463*x470*x471))+((x463*x465))+((r02*x466*x467))+(((-1.0)*x465))+(((-1.0)*x468))+((r12*x466*x469))+((r02*x466*x470))+(((-1.0)*x464*x465*x472))+((r12*x466*x471))+(((-1.0)*r02*r12*x472))+((x463*x464*x468))+((x463*x467*x469)));
j3eval[0]=x473;
j3eval[1]=IKsign(x473);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
continue; // 1 cases reached

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x474=cj4*cj4;
IkReal x475=cj5*cj5;
IkReal x476=(cj4*r02);
IkReal x477=(r10*sj5);
IkReal x478=((1.0)*r01);
IkReal x479=(r00*r10);
IkReal x480=(cj2*sj1);
IkReal x481=(cj5*r00);
IkReal x482=(cj1*sj2);
IkReal x483=(cj5*sj4);
IkReal x484=(cj4*r12);
IkReal x485=((1.0)*x474);
IkReal x486=(r11*x474);
IkReal x487=(r00*sj4*sj5);
CheckValue<IkReal> x488=IKPowWithIntegerCheck(IKsign((((x484*x487))+(((-1.0)*x475*x479*x485))+((sj4*x476*x477))+((sj5*x481*x486))+(((-1.0)*x479))+(((-1.0)*r11*x478))+((cj5*r01*x474*x477))+((r01*x483*x484))+((r01*x475*x486))+((x474*x479))+((r11*x476*x483))+(((-1.0)*r02*r12*x485)))),-1);
if(!x488.valid){
continue;
}
CheckValue<IkReal> x489 = IKatan2WithCheck(IkReal((((x476*x482))+((x476*x480))+(((-1.0)*x478*x480*x483))+(((-1.0)*x482*x487))+(((-1.0)*x480*x487))+(((-1.0)*x478*x482*x483)))),IkReal(((((-1.0)*sj5*x478*x480))+(((-1.0)*sj5*x478*x482))+((x481*x482))+((x480*x481)))),IKFAST_ATAN2_MAGTHRESH);
if(!x489.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x488.value)))+(x489.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x490=IKcos(j3);
IkReal x491=IKsin(j3);
IkReal x492=((1.0)*cj5);
IkReal x493=(sj4*sj5);
IkReal x494=(sj1*sj2);
IkReal x495=((1.0)*cj2);
IkReal x496=(r21*sj4);
IkReal x497=((1.0)*cj1*sj2);
IkReal x498=(sj1*x495);
IkReal x499=(r20*x490);
IkReal x500=(r10*x491);
IkReal x501=(r20*x491);
IkReal x502=(r10*x490);
IkReal x503=(cj5*r01*sj4);
IkReal x504=(cj5*x491);
IkReal x505=(r11*x490);
IkReal x506=(r00*x490);
IkReal x507=(sj5*x490);
IkReal x508=((1.0)*cj4*x491);
IkReal x509=((1.0)*cj4*x490);
IkReal x510=((1.0)*sj5*x491);
IkReal x511=(x498+x497);
evalcond[0]=((((-1.0)*r01*x510))+((x490*x503))+((x493*x506))+((r00*x504))+(((-1.0)*r02*x509)));
evalcond[1]=(((r01*x507))+((x491*x503))+(((-1.0)*x492*x506))+((r00*x491*x493))+(((-1.0)*r02*x508)));
evalcond[2]=(((r21*x507))+(((-1.0)*cj1*x495))+(((-1.0)*r22*x508))+((x493*x501))+x494+((x496*x504))+(((-1.0)*x492*x499)));
evalcond[3]=((((-1.0)*r11*x510))+((x493*x502))+(((-1.0)*x494))+((cj5*x500))+((cj1*cj2))+((cj5*sj4*x505))+(((-1.0)*r12*x509)));
evalcond[4]=(((x493*x499))+(((-1.0)*r22*x509))+((cj5*x501))+(((-1.0)*r21*x510))+(((-1.0)*x511))+((cj5*x490*x496)));
evalcond[5]=(((sj5*x505))+((x493*x500))+(((-1.0)*x492*x502))+(((-1.0)*x511))+(((-1.0)*r12*x508))+((r11*sj4*x504)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x512=((1.0)*r01);
IkReal x513=(cj1*cj2);
IkReal x514=(cj5*sj4);
IkReal x515=(sj1*sj2);
IkReal x516=(cj4*r02);
IkReal x517=((1.0)*sj4);
IkReal x518=((1.0)*cj4);
IkReal x519=(r00*sj5);
IkReal x520=(cj5*r00);
CheckValue<IkReal> x521 = IKatan2WithCheck(IkReal((((r01*sj5*x515))+(((-1.0)*sj5*x512*x513))+(((-1.0)*x515*x520))+((x513*x520)))),IkReal(((((-1.0)*x512*x514*x515))+((sj4*x513*x519))+((r01*x513*x514))+(((-1.0)*x515*x517*x519))+(((-1.0)*x513*x516))+((x515*x516)))),IKFAST_ATAN2_MAGTHRESH);
if(!x521.valid){
continue;
}
CheckValue<IkReal> x522=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj5*r11*x518))+(((-1.0)*r12*x517))+(((-1.0)*r10*sj5*x518)))),-1);
if(!x522.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x521.value)+(((1.5707963267949)*(x522.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x523=IKcos(j3);
IkReal x524=IKsin(j3);
IkReal x525=((1.0)*cj5);
IkReal x526=(sj4*sj5);
IkReal x527=(sj1*sj2);
IkReal x528=((1.0)*cj2);
IkReal x529=(r21*sj4);
IkReal x530=((1.0)*cj1*sj2);
IkReal x531=(sj1*x528);
IkReal x532=(r20*x523);
IkReal x533=(r10*x524);
IkReal x534=(r20*x524);
IkReal x535=(r10*x523);
IkReal x536=(cj5*r01*sj4);
IkReal x537=(cj5*x524);
IkReal x538=(r11*x523);
IkReal x539=(r00*x523);
IkReal x540=(sj5*x523);
IkReal x541=((1.0)*cj4*x524);
IkReal x542=((1.0)*cj4*x523);
IkReal x543=((1.0)*sj5*x524);
IkReal x544=(x531+x530);
evalcond[0]=(((x526*x539))+(((-1.0)*r01*x543))+(((-1.0)*r02*x542))+((x523*x536))+((r00*x537)));
evalcond[1]=((((-1.0)*x525*x539))+(((-1.0)*r02*x541))+((r00*x524*x526))+((x524*x536))+((r01*x540)));
evalcond[2]=(((r21*x540))+(((-1.0)*r22*x541))+(((-1.0)*x525*x532))+((x526*x534))+(((-1.0)*cj1*x528))+x527+((x529*x537)));
evalcond[3]=(((cj5*x533))+(((-1.0)*x527))+((x526*x535))+((cj1*cj2))+(((-1.0)*r12*x542))+((cj5*sj4*x538))+(((-1.0)*r11*x543)));
evalcond[4]=((((-1.0)*r22*x542))+((cj5*x534))+((cj5*x523*x529))+((x526*x532))+(((-1.0)*x544))+(((-1.0)*r21*x543)));
evalcond[5]=((((-1.0)*x525*x535))+((x526*x533))+((sj5*x538))+(((-1.0)*x544))+((r11*sj4*x537))+(((-1.0)*r12*x541)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x545=(cj1*sj4);
IkReal x546=(cj5*r11);
IkReal x547=((0.309140685009749)*sj5);
IkReal x548=(sj1*sj4);
IkReal x549=(cj5*r21);
IkReal x550=(pz*sj1);
IkReal x551=((0.0808303625942922)*sj5);
IkReal x552=((0.0808303625942922)*cj4);
IkReal x553=((4.29362062513541)*cj1);
IkReal x554=(r12*sj1);
IkReal x555=(cj1*r12);
IkReal x556=((0.309140685009749)*cj4);
IkReal x557=((1.12264392492073)*cj1);
IkReal x558=(py*sj1);
IkReal x559=(r22*x556);
if( IKabs(((0.392925373722254)+(((4.29362062513541)*x558))+(((-1.0)*x554*x556))+(((-1.0)*r20*x545*x547))+((r10*x547*x548))+(((-1.12264392492073)*x550))+((cj1*x559))+(((-0.309140685009749)*x545*x549))+(((-1.0)*r20*x548*x551))+(((-1.0)*r10*x545*x551))+(((-0.0808303625942922)*x548*x549))+(((0.309140685009749)*x546*x548))+((r22*sj1*x552))+(((-1.0)*py*x557))+(((-0.0808303625942922)*x545*x546))+(((-1.0)*pz*x553))+((x552*x555)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((1.50276721879739)+((sj1*x559))+((pz*x557))+((r20*x545*x551))+(((-1.12264392492073)*x558))+(((-1.0)*r10*x548*x551))+((x555*x556))+(((-0.309140685009749)*x545*x546))+(((-0.309140685009749)*x548*x549))+(((-4.29362062513541)*x550))+(((-0.0808303625942922)*x546*x548))+(((-1.0)*r10*x545*x547))+(((-1.0)*py*x553))+(((-1.0)*r20*x547*x548))+(((0.0808303625942922)*x545*x549))+((x552*x554))+(((-1.0)*cj1*r22*x552)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.392925373722254)+(((4.29362062513541)*x558))+(((-1.0)*x554*x556))+(((-1.0)*r20*x545*x547))+((r10*x547*x548))+(((-1.12264392492073)*x550))+((cj1*x559))+(((-0.309140685009749)*x545*x549))+(((-1.0)*r20*x548*x551))+(((-1.0)*r10*x545*x551))+(((-0.0808303625942922)*x548*x549))+(((0.309140685009749)*x546*x548))+((r22*sj1*x552))+(((-1.0)*py*x557))+(((-0.0808303625942922)*x545*x546))+(((-1.0)*pz*x553))+((x552*x555))))+IKsqr(((1.50276721879739)+((sj1*x559))+((pz*x557))+((r20*x545*x551))+(((-1.12264392492073)*x558))+(((-1.0)*r10*x548*x551))+((x555*x556))+(((-0.309140685009749)*x545*x546))+(((-0.309140685009749)*x548*x549))+(((-4.29362062513541)*x550))+(((-0.0808303625942922)*x546*x548))+(((-1.0)*r10*x545*x547))+(((-1.0)*py*x553))+(((-1.0)*r20*x547*x548))+(((0.0808303625942922)*x545*x549))+((x552*x554))+(((-1.0)*cj1*r22*x552))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((0.392925373722254)+(((4.29362062513541)*x558))+(((-1.0)*x554*x556))+(((-1.0)*r20*x545*x547))+((r10*x547*x548))+(((-1.12264392492073)*x550))+((cj1*x559))+(((-0.309140685009749)*x545*x549))+(((-1.0)*r20*x548*x551))+(((-1.0)*r10*x545*x551))+(((-0.0808303625942922)*x548*x549))+(((0.309140685009749)*x546*x548))+((r22*sj1*x552))+(((-1.0)*py*x557))+(((-0.0808303625942922)*x545*x546))+(((-1.0)*pz*x553))+((x552*x555))), ((1.50276721879739)+((sj1*x559))+((pz*x557))+((r20*x545*x551))+(((-1.12264392492073)*x558))+(((-1.0)*r10*x548*x551))+((x555*x556))+(((-0.309140685009749)*x545*x546))+(((-0.309140685009749)*x548*x549))+(((-4.29362062513541)*x550))+(((-0.0808303625942922)*x546*x548))+(((-1.0)*r10*x545*x547))+(((-1.0)*py*x553))+(((-1.0)*r20*x547*x548))+(((0.0808303625942922)*x545*x549))+((x552*x554))+(((-1.0)*cj1*r22*x552))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[2];
IkReal x560=IKcos(j2);
IkReal x561=IKsin(j2);
IkReal x562=((0.072)*sj4);
IkReal x563=((0.072)*cj4);
IkReal x564=((0.057)*x561);
IkReal x565=((0.218)*x560);
IkReal x566=((0.218)*x561);
IkReal x567=((0.057)*x560);
evalcond[0]=(((cj1*x567))+(((-1.0)*cj5*r21*x562))+((r22*x563))+(((0.35)*sj1))+(((-1.0)*pz))+(((-1.0)*cj1*x566))+(((-1.0)*sj1*x565))+(((-1.0)*sj1*x564))+(((-1.0)*r20*sj5*x562)));
evalcond[1]=((((-1.0)*cj5*r11*x562))+(((-1.0)*r10*sj5*x562))+(((-1.0)*py))+(((-1.0)*cj1*x564))+(((-1.0)*cj1*x565))+((sj1*x566))+((r12*x563))+(((-1.0)*sj1*x567))+(((0.35)*cj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[2];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x568=((1.0)*cj4);
IkReal x569=((((-1.0)*cj5*r11*x568))+(((-1.0)*r10*sj5*x568))+(((-1.0)*r12*sj4)));
j3eval[0]=x569;
j3eval[1]=IKsign(x569);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x570=cj4*cj4;
IkReal x571=cj5*cj5;
IkReal x572=(r00*r10);
IkReal x573=(cj4*sj4);
IkReal x574=(r10*sj5);
IkReal x575=(r01*r11);
IkReal x576=(cj5*r01);
IkReal x577=(cj5*r11);
IkReal x578=(r00*sj5);
IkReal x579=((1.0)*x570);
IkReal x580=(((x570*x577*x578))+((r12*x573*x576))+((r12*x573*x578))+(((-1.0)*x571*x572*x579))+((x570*x574*x576))+((r02*x573*x577))+((r02*x573*x574))+(((-1.0)*x572))+(((-1.0)*x575))+((x570*x571*x575))+(((-1.0)*r02*r12*x579))+((x570*x572)));
j3eval[0]=x580;
j3eval[1]=IKsign(x580);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
continue; // 1 cases reached

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x581=cj4*cj4;
IkReal x582=cj5*cj5;
IkReal x583=(cj5*r01);
IkReal x584=(cj4*r02);
IkReal x585=(sj4*sj5);
IkReal x586=(r01*r11);
IkReal x587=(r00*r10);
IkReal x588=(cj2*sj1);
IkReal x589=(r01*sj5);
IkReal x590=(r00*sj5);
IkReal x591=(cj5*r11);
IkReal x592=(cj1*sj2);
IkReal x593=(cj4*r12);
IkReal x594=(sj4*x592);
IkReal x595=((1.0)*x581);
IkReal x596=((1.0)*cj5*r00);
CheckValue<IkReal> x597 = IKatan2WithCheck(IkReal(((((-1.0)*x584*x592))+((r00*x585*x588))+((x583*x594))+(((-1.0)*x584*x588))+((r00*x585*x592))+((sj4*x583*x588)))),IkReal(((((-1.0)*x588*x596))+((x588*x589))+(((-1.0)*x592*x596))+((x589*x592)))),IKFAST_ATAN2_MAGTHRESH);
if(!x597.valid){
continue;
}
CheckValue<IkReal> x598=IKPowWithIntegerCheck(IKsign(((((-1.0)*x586))+(((-1.0)*x587))+((x581*x587))+((r10*sj5*x581*x583))+((sj4*x583*x593))+(((-1.0)*r02*r12*x595))+((sj4*x584*x591))+(((-1.0)*x582*x587*x595))+((x581*x590*x591))+((r00*x585*x593))+((r10*x584*x585))+((x581*x582*x586)))),-1);
if(!x598.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x597.value)+(((1.5707963267949)*(x598.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x599=IKcos(j3);
IkReal x600=IKsin(j3);
IkReal x601=(sj1*sj2);
IkReal x602=((1.0)*cj5);
IkReal x603=(sj4*sj5);
IkReal x604=((1.0)*cj4);
IkReal x605=((1.0)*cj2);
IkReal x606=(r01*sj4);
IkReal x607=(cj1*sj2);
IkReal x608=(r11*sj4);
IkReal x609=(r21*sj4);
IkReal x610=(cj1*x605);
IkReal x611=(r20*x599);
IkReal x612=(r10*x600);
IkReal x613=(r20*x600);
IkReal x614=(r10*x599);
IkReal x615=(cj5*x600);
IkReal x616=(cj5*x599);
IkReal x617=(sj5*x599);
IkReal x618=(r00*x599);
IkReal x619=((1.0)*sj5*x600);
evalcond[0]=(((r00*x615))+(((-1.0)*r01*x619))+(((-1.0)*r02*x599*x604))+((x603*x618))+((x606*x616)));
evalcond[1]=(((r01*x617))+(((-1.0)*r02*x600*x604))+((x606*x615))+((r00*x600*x603))+(((-1.0)*x602*x618)));
evalcond[2]=(((cj2*sj1))+(((-1.0)*r12*x600*x604))+((x608*x615))+((r11*x617))+((x603*x612))+x607+(((-1.0)*x602*x614)));
evalcond[3]=((((-1.0)*r22*x600*x604))+((x603*x613))+((r21*x617))+(((-1.0)*x610))+x601+((x609*x615))+(((-1.0)*x602*x611)));
evalcond[4]=((((-1.0)*r12*x599*x604))+((x608*x616))+(((-1.0)*r11*x619))+((x603*x614))+(((-1.0)*x610))+x601+((cj5*x612)));
evalcond[5]=((((-1.0)*r21*x619))+(((-1.0)*sj1*x605))+(((-1.0)*x607))+((x603*x611))+((x609*x616))+(((-1.0)*r22*x599*x604))+((cj5*x613)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x620=((1.0)*r01);
IkReal x621=(cj1*cj2);
IkReal x622=(cj5*sj4);
IkReal x623=(sj1*sj2);
IkReal x624=(cj4*r02);
IkReal x625=((1.0)*sj4);
IkReal x626=((1.0)*cj4);
IkReal x627=(r00*sj5);
IkReal x628=(cj5*r00);
CheckValue<IkReal> x629 = IKatan2WithCheck(IkReal(((((-1.0)*sj5*x620*x621))+(((-1.0)*x623*x628))+((r01*sj5*x623))+((x621*x628)))),IkReal((((r01*x621*x622))+(((-1.0)*x623*x625*x627))+(((-1.0)*x620*x622*x623))+((sj4*x621*x627))+(((-1.0)*x621*x624))+((x623*x624)))),IKFAST_ATAN2_MAGTHRESH);
if(!x629.valid){
continue;
}
CheckValue<IkReal> x630=IKPowWithIntegerCheck(IKsign(((((-1.0)*r12*x625))+(((-1.0)*r10*sj5*x626))+(((-1.0)*cj5*r11*x626)))),-1);
if(!x630.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x629.value)+(((1.5707963267949)*(x630.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x631=IKcos(j3);
IkReal x632=IKsin(j3);
IkReal x633=(sj1*sj2);
IkReal x634=((1.0)*cj5);
IkReal x635=(sj4*sj5);
IkReal x636=((1.0)*cj4);
IkReal x637=((1.0)*cj2);
IkReal x638=(r01*sj4);
IkReal x639=(cj1*sj2);
IkReal x640=(r11*sj4);
IkReal x641=(r21*sj4);
IkReal x642=(cj1*x637);
IkReal x643=(r20*x631);
IkReal x644=(r10*x632);
IkReal x645=(r20*x632);
IkReal x646=(r10*x631);
IkReal x647=(cj5*x632);
IkReal x648=(cj5*x631);
IkReal x649=(sj5*x631);
IkReal x650=(r00*x631);
IkReal x651=((1.0)*sj5*x632);
evalcond[0]=(((x638*x648))+((x635*x650))+(((-1.0)*r02*x631*x636))+(((-1.0)*r01*x651))+((r00*x647)));
evalcond[1]=(((x638*x647))+((r00*x632*x635))+(((-1.0)*r02*x632*x636))+((r01*x649))+(((-1.0)*x634*x650)));
evalcond[2]=(((cj2*sj1))+((x635*x644))+((x640*x647))+x639+((r11*x649))+(((-1.0)*x634*x646))+(((-1.0)*r12*x632*x636)));
evalcond[3]=(((x635*x645))+((x641*x647))+(((-1.0)*x642))+((r21*x649))+x633+(((-1.0)*r22*x632*x636))+(((-1.0)*x634*x643)));
evalcond[4]=(((x635*x646))+(((-1.0)*r11*x651))+((cj5*x644))+((x640*x648))+(((-1.0)*x642))+x633+(((-1.0)*r12*x631*x636)));
evalcond[5]=(((x635*x643))+((cj5*x645))+((x641*x648))+(((-1.0)*r22*x631*x636))+(((-1.0)*sj1*x637))+(((-1.0)*x639))+(((-1.0)*r21*x651)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x652=(cj1*sj0);
IkReal x653=((0.015696)*sj1);
IkReal x654=(cj4*r12);
IkReal x655=((0.057)*pz);
IkReal x656=(cj1*r10);
IkReal x657=((0.057)*py);
IkReal x658=(cj1*r11);
IkReal x659=(sj4*sj5);
IkReal x660=(r20*sj0);
IkReal x661=((0.218)*pz);
IkReal x662=(sj0*sj1);
IkReal x663=(cj5*sj4);
IkReal x664=((0.218)*py);
IkReal x665=(cj4*r22);
IkReal x666=((0.004104)*x665);
IkReal x667=((0.004104)*x659);
IkReal x668=((0.004104)*x663);
IkReal x669=((0.015696)*x663);
CheckValue<IkReal> x670 = IKatan2WithCheck(IkReal(((((-1.0)*sj1*x664))+((x662*x666))+(((-0.004104)*cj1*x654))+(((-1.0)*sj1*x660*x667))+((cj1*x657))+(((-1.0)*r11*x653*x663))+((x656*x667))+((x653*x654))+(((-1.0)*r21*x652*x669))+(((-1.0)*r10*x653*x659))+(((0.01995)*sj0))+(((-1.0)*x655*x662))+((x658*x668))+(((0.015696)*x652*x665))+(((-1.0)*x652*x661))+(((-1.0)*r21*x662*x668))+(((-0.015696)*r20*x652*x659)))),IkReal((((r10*sj1*x667))+(((0.015696)*x656*x659))+(((-1.0)*r21*sj0*x653*x663))+((r11*sj1*x668))+((sj1*x657))+((x652*x655))+(((-1.0)*x653*x659*x660))+(((-1.0)*x661*x662))+(((-0.004104)*sj1*x654))+((cj1*x664))+(((-0.015696)*cj1*x654))+((x658*x669))+(((0.0763)*sj0))+((r21*x652*x668))+((sj0*x653*x665))+(((-1.0)*x652*x666))+((r20*x652*x667)))),IKFAST_ATAN2_MAGTHRESH);
if(!x670.valid){
continue;
}
CheckValue<IkReal> x671=IKPowWithIntegerCheck(IKsign(sj0),-1);
if(!x671.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x670.value)+(((1.5707963267949)*(x671.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x672=IKcos(j2);
IkReal x673=IKsin(j2);
IkReal x674=(cj1*sj0);
IkReal x675=((0.072)*sj4);
IkReal x676=(cj0*cj1);
IkReal x677=((0.072)*cj4);
IkReal x678=((0.057)*x673);
IkReal x679=((0.218)*x672);
IkReal x680=((0.218)*x673);
IkReal x681=((0.057)*sj1*x672);
evalcond[0]=((((-1.0)*r20*sj5*x675))+(((-1.0)*cj5*r21*x675))+(((-1.0)*cj1*x680))+((r22*x677))+(((0.35)*sj1))+(((-1.0)*pz))+(((0.057)*cj1*x672))+(((-1.0)*sj1*x678))+(((-1.0)*sj1*x679)));
evalcond[1]=(((r02*x677))+(((-1.0)*r00*sj5*x675))+((x676*x678))+((x676*x679))+(((-1.0)*px))+(((-1.0)*cj5*r01*x675))+(((-1.0)*cj0*sj1*x680))+(((-0.35)*x676))+((cj0*x681)));
evalcond[2]=(((r12*x677))+((x674*x678))+((x674*x679))+(((-1.0)*r10*sj5*x675))+(((-1.0)*sj0*sj1*x680))+(((-1.0)*py))+(((-0.35)*x674))+((sj0*x681))+(((-1.0)*cj5*r11*x675)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[2];
IkReal x682=(((cj4*r00*sj5))+((r02*sj4))+((cj4*cj5*r01)));
j3eval[0]=x682;
j3eval[1]=IKsign(x682);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
IkReal x683=((1.0)*cj4);
IkReal x684=((((-1.0)*r10*sj5*x683))+(((-1.0)*cj5*r11*x683))+(((-1.0)*r12*sj4)));
j3eval[0]=x684;
j3eval[1]=IKsign(x684);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
IkReal x685=cj4*cj4;
IkReal x686=cj5*cj5;
IkReal x687=r20*r20;
IkReal x688=r21*r21;
IkReal x689=(r20*sj5);
IkReal x690=(cj5*r21);
IkReal x691=((1.0)*x687);
IkReal x692=((2.0)*cj4*r22*sj4);
IkReal x693=(x685*x686);
IkReal x694=((((-1.0)*x685*(r22*r22)))+((x688*x693))+((x690*x692))+((x685*x687))+((x689*x692))+(((2.0)*x685*x689*x690))+(((-1.0)*x691))+(((-1.0)*x691*x693))+(((-1.0)*x688)));
j3eval[0]=x694;
j3eval[1]=IKsign(x694);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x695=cj4*cj4;
IkReal x696=cj5*cj5;
IkReal x697=r20*r20;
IkReal x698=r21*r21;
IkReal x699=((1.0)*cj5);
IkReal x700=(r21*sj2);
IkReal x701=(cj1*sj4);
IkReal x702=(cj2*sj1);
IkReal x703=(cj4*r22);
IkReal x704=(sj1*sj5);
IkReal x705=(r20*sj5);
IkReal x706=((2.0)*sj4);
IkReal x707=(cj1*cj2);
IkReal x708=(r21*sj5);
IkReal x709=(cj1*sj2);
IkReal x710=((1.0)*sj2);
IkReal x711=(cj5*r21);
IkReal x712=(r20*sj2);
IkReal x713=((1.0)*x697);
IkReal x714=(x695*x696);
CheckValue<IkReal> x715=IKPowWithIntegerCheck(IKsign(((((-1.0)*x695*(r22*r22)))+((x703*x705*x706))+((x695*x697))+(((-1.0)*x713))+(((2.0)*x695*x705*x711))+((x698*x714))+(((-1.0)*x713*x714))+((x703*x706*x711))+(((-1.0)*x698)))),-1);
if(!x715.valid){
continue;
}
CheckValue<IkReal> x716 = IKatan2WithCheck(IkReal((((sj4*x704*x712))+((x702*x708))+(((-1.0)*cj2*r21*x699*x701))+((x703*x707))+((cj5*sj1*sj4*x700))+(((-1.0)*r20*x699*x709))+(((-1.0)*r20*x699*x702))+(((-1.0)*sj1*x703*x710))+((cj1*sj5*x700))+(((-1.0)*cj2*x701*x705)))),IkReal(((((-1.0)*sj1*x699*x712))+((x702*x703))+((x700*x704))+((cj5*r20*x707))+((x703*x709))+(((-1.0)*x699*x700*x701))+(((-1.0)*sj4*x702*x705))+(((-1.0)*r21*sj4*x699*x702))+(((-1.0)*x707*x708))+(((-1.0)*x701*x705*x710)))),IKFAST_ATAN2_MAGTHRESH);
if(!x716.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x715.value)))+(x716.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x717=IKsin(j3);
IkReal x718=IKcos(j3);
IkReal x719=((1.0)*cj5);
IkReal x720=(cj1*cj2);
IkReal x721=(sj4*sj5);
IkReal x722=(sj1*sj2);
IkReal x723=(cj5*sj4);
IkReal x724=(r20*x718);
IkReal x725=(r10*x717);
IkReal x726=(r20*x717);
IkReal x727=((1.0)*cj2*sj1);
IkReal x728=((1.0)*cj1*sj2);
IkReal x729=(r01*x718);
IkReal x730=(r00*x717);
IkReal x731=(r11*x718);
IkReal x732=(r10*x718);
IkReal x733=(r00*x718);
IkReal x734=(r21*x718);
IkReal x735=((1.0)*cj4*x717);
IkReal x736=((1.0)*cj4*x718);
IkReal x737=((1.0)*sj5*x717);
evalcond[0]=(((x721*x726))+((r21*x717*x723))+(((-1.0)*x720))+((sj5*x734))+x722+(((-1.0)*x719*x724))+(((-1.0)*r22*x735)));
evalcond[1]=(((x721*x724))+((cj5*x726))+((x723*x734))+(((-1.0)*x728))+(((-1.0)*x727))+(((-1.0)*r21*x737))+(((-1.0)*r22*x736)));
evalcond[2]=((((-1.0)*r01*x737))+((x721*x733))+((cj5*x730))+((x723*x729))+(((-1.0)*r02*x736))+((cj0*x720))+(((-1.0)*cj0*x722)));
evalcond[3]=(((x721*x732))+((cj5*x725))+((x723*x731))+(((-1.0)*sj0*x722))+((sj0*x720))+(((-1.0)*r12*x736))+(((-1.0)*r11*x737)));
evalcond[4]=(((r01*x717*x723))+((x721*x730))+(((-1.0)*cj0*x728))+(((-1.0)*cj0*x727))+(((-1.0)*r02*x735))+((sj5*x729))+(((-1.0)*x719*x733)));
evalcond[5]=(((x721*x725))+(((-1.0)*sj0*x728))+(((-1.0)*sj0*x727))+((r11*x717*x723))+((sj5*x731))+(((-1.0)*x719*x732))+(((-1.0)*r12*x735)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x738=(cj0*cj2);
IkReal x739=(r01*sj2);
IkReal x740=(cj2*r01);
IkReal x741=(cj1*sj5);
IkReal x742=(sj4*sj5);
IkReal x743=(cj4*r02);
IkReal x744=(sj1*sj2);
IkReal x745=((1.0)*cj1);
IkReal x746=((1.0)*sj4);
IkReal x747=((1.0)*r00);
IkReal x748=(cj0*sj2);
IkReal x749=(cj4*r22);
IkReal x750=(sj1*sj5);
IkReal x751=((1.0)*cj4);
IkReal x752=(cj2*r00);
IkReal x753=(cj1*cj5*sj4);
IkReal x754=((1.0)*r20*sj1);
IkReal x755=(r21*x748);
IkReal x756=(cj5*sj1*x746);
CheckValue<IkReal> x757 = IKatan2WithCheck(IkReal((((cj1*cj5*x752))+((x739*x750))+(((-1.0)*cj5*r20*x745*x748))+(((-1.0)*cj5*x744*x747))+((x741*x755))+(((-1.0)*x740*x741))+(((-1.0)*cj5*x738*x754))+((r21*x738*x750)))),IkReal(((((-1.0)*r21*x738*x756))+(((-1.0)*x738*x742*x754))+(((-1.0)*x739*x756))+(((-1.0)*x742*x744*x747))+((cj1*x748*x749))+(((-1.0)*cj2*x743*x745))+((x740*x753))+((sj4*x741*x752))+((x743*x744))+((sj1*x738*x749))+(((-1.0)*cj5*sj4*x745*x755))+(((-1.0)*r20*x741*x746*x748)))),IKFAST_ATAN2_MAGTHRESH);
if(!x757.valid){
continue;
}
CheckValue<IkReal> x758=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj5*r11*x751))+(((-1.0)*r12*x746))+(((-1.0)*r10*sj5*x751)))),-1);
if(!x758.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x757.value)+(((1.5707963267949)*(x758.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x759=IKsin(j3);
IkReal x760=IKcos(j3);
IkReal x761=((1.0)*cj5);
IkReal x762=(cj1*cj2);
IkReal x763=(sj4*sj5);
IkReal x764=(sj1*sj2);
IkReal x765=(cj5*sj4);
IkReal x766=(r20*x760);
IkReal x767=(r10*x759);
IkReal x768=(r20*x759);
IkReal x769=((1.0)*cj2*sj1);
IkReal x770=((1.0)*cj1*sj2);
IkReal x771=(r01*x760);
IkReal x772=(r00*x759);
IkReal x773=(r11*x760);
IkReal x774=(r10*x760);
IkReal x775=(r00*x760);
IkReal x776=(r21*x760);
IkReal x777=((1.0)*cj4*x759);
IkReal x778=((1.0)*cj4*x760);
IkReal x779=((1.0)*sj5*x759);
evalcond[0]=(((x763*x768))+(((-1.0)*r22*x777))+(((-1.0)*x762))+x764+((sj5*x776))+((r21*x759*x765))+(((-1.0)*x761*x766)));
evalcond[1]=((((-1.0)*x769))+((x763*x766))+(((-1.0)*r22*x778))+((cj5*x768))+((x765*x776))+(((-1.0)*x770))+(((-1.0)*r21*x779)));
evalcond[2]=((((-1.0)*cj0*x764))+(((-1.0)*r02*x778))+(((-1.0)*r01*x779))+((x765*x771))+((cj0*x762))+((x763*x775))+((cj5*x772)));
evalcond[3]=((((-1.0)*sj0*x764))+(((-1.0)*r11*x779))+((sj0*x762))+(((-1.0)*r12*x778))+((cj5*x767))+((x765*x773))+((x763*x774)));
evalcond[4]=((((-1.0)*cj0*x770))+((r01*x759*x765))+(((-1.0)*r02*x777))+((x763*x772))+((sj5*x771))+(((-1.0)*x761*x775))+(((-1.0)*cj0*x769)));
evalcond[5]=((((-1.0)*sj0*x769))+(((-1.0)*r12*x777))+((x763*x767))+((r11*x759*x765))+((sj5*x773))+(((-1.0)*sj0*x770))+(((-1.0)*x761*x774)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x780=((1.0)*sj1);
IkReal x781=(cj5*r10);
IkReal x782=(cj1*cj2);
IkReal x783=(sj4*sj5);
IkReal x784=(cj4*r12);
IkReal x785=(cj2*sj0);
IkReal x786=(cj4*r22);
IkReal x787=((1.0)*r20);
IkReal x788=(sj1*sj5);
IkReal x789=(r11*sj2);
IkReal x790=(cj5*sj4);
IkReal x791=(cj1*sj0*sj2);
CheckValue<IkReal> x792 = IKatan2WithCheck(IkReal((((x781*x782))+(((-1.0)*cj5*x787*x791))+((x788*x789))+(((-1.0)*r11*sj5*x782))+(((-1.0)*sj2*x780*x781))+((r21*sj5*x791))+((r21*x785*x788))+(((-1.0)*cj5*r20*x780*x785)))),IkReal(((((-1.0)*x783*x787*x791))+((x786*x791))+((sj1*x785*x786))+((sj1*sj2*x784))+(((-1.0)*r10*sj2*x780*x783))+((r11*x782*x790))+((r10*x782*x783))+(((-1.0)*r21*x780*x785*x790))+(((-1.0)*x780*x789*x790))+(((-1.0)*r21*x790*x791))+(((-1.0)*x782*x784))+(((-1.0)*r20*x780*x783*x785)))),IKFAST_ATAN2_MAGTHRESH);
if(!x792.valid){
continue;
}
CheckValue<IkReal> x793=IKPowWithIntegerCheck(IKsign((((cj4*r00*sj5))+((r02*sj4))+((cj4*cj5*r01)))),-1);
if(!x793.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x792.value)+(((1.5707963267949)*(x793.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x794=IKsin(j3);
IkReal x795=IKcos(j3);
IkReal x796=((1.0)*cj5);
IkReal x797=(cj1*cj2);
IkReal x798=(sj4*sj5);
IkReal x799=(sj1*sj2);
IkReal x800=(cj5*sj4);
IkReal x801=(r20*x795);
IkReal x802=(r10*x794);
IkReal x803=(r20*x794);
IkReal x804=((1.0)*cj2*sj1);
IkReal x805=((1.0)*cj1*sj2);
IkReal x806=(r01*x795);
IkReal x807=(r00*x794);
IkReal x808=(r11*x795);
IkReal x809=(r10*x795);
IkReal x810=(r00*x795);
IkReal x811=(r21*x795);
IkReal x812=((1.0)*cj4*x794);
IkReal x813=((1.0)*cj4*x795);
IkReal x814=((1.0)*sj5*x794);
evalcond[0]=((((-1.0)*x796*x801))+((sj5*x811))+((x798*x803))+((r21*x794*x800))+(((-1.0)*r22*x812))+x799+(((-1.0)*x797)));
evalcond[1]=(((cj5*x803))+((x798*x801))+(((-1.0)*r22*x813))+((x800*x811))+(((-1.0)*x804))+(((-1.0)*x805))+(((-1.0)*r21*x814)));
evalcond[2]=(((cj5*x807))+((x800*x806))+(((-1.0)*cj0*x799))+(((-1.0)*r02*x813))+((cj0*x797))+(((-1.0)*r01*x814))+((x798*x810)));
evalcond[3]=(((cj5*x802))+((x800*x808))+(((-1.0)*sj0*x799))+(((-1.0)*r11*x814))+((sj0*x797))+(((-1.0)*r12*x813))+((x798*x809)));
evalcond[4]=((((-1.0)*x796*x810))+((r01*x794*x800))+((x798*x807))+(((-1.0)*cj0*x805))+(((-1.0)*cj0*x804))+(((-1.0)*r02*x812))+((sj5*x806)));
evalcond[5]=((((-1.0)*x796*x809))+(((-1.0)*r12*x812))+((x798*x802))+(((-1.0)*sj0*x804))+(((-1.0)*sj0*x805))+((r11*x794*x800))+((sj5*x808)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x815=(cj0*cj1);
IkReal x816=(cj4*r22);
IkReal x817=((0.015696)*sj4);
IkReal x818=(r20*sj5);
IkReal x819=(cj0*sj1);
IkReal x820=((0.218)*px);
IkReal x821=(cj5*r21);
IkReal x822=((0.004104)*sj4);
IkReal x823=((0.057)*px);
IkReal x824=(r00*sj5);
IkReal x825=((0.218)*pz);
IkReal x826=((0.057)*pz);
IkReal x827=(cj1*cj4*r02);
IkReal x828=(cj4*r02*sj1);
IkReal x829=(cj1*cj5*r01);
IkReal x830=(cj5*r01*sj1*sj4);
CheckValue<IkReal> x831 = IKatan2WithCheck(IkReal(((((-0.004104)*x827))+(((0.015696)*x828))+(((-1.0)*x815*x817*x821))+(((-1.0)*cj5*r01*sj1*x817))+(((0.015696)*x815*x816))+(((-1.0)*sj1*x817*x824))+(((-1.0)*x819*x826))+(((-1.0)*x815*x825))+(((-1.0)*x815*x817*x818))+(((0.004104)*x816*x819))+(((0.01995)*cj0))+(((-1.0)*x818*x819*x822))+((cj1*x822*x824))+((x822*x829))+(((-1.0)*sj1*x820))+(((-1.0)*x819*x821*x822))+((cj1*x823)))),IkReal(((((-0.004104)*x828))+((sj1*x823))+((x815*x826))+(((-1.0)*x819*x825))+((cj1*x817*x824))+((cj5*r01*sj1*x822))+((x817*x829))+(((-1.0)*x817*x818*x819))+(((-1.0)*x817*x819*x821))+(((-0.004104)*x815*x816))+(((0.0763)*cj0))+((x815*x818*x822))+(((-0.015696)*x827))+(((0.015696)*x816*x819))+((cj1*x820))+((sj1*x822*x824))+((x815*x821*x822)))),IKFAST_ATAN2_MAGTHRESH);
if(!x831.valid){
continue;
}
CheckValue<IkReal> x832=IKPowWithIntegerCheck(IKsign(cj0),-1);
if(!x832.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x831.value)+(((1.5707963267949)*(x832.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x833=IKcos(j2);
IkReal x834=IKsin(j2);
IkReal x835=(cj1*sj0);
IkReal x836=((0.072)*sj4);
IkReal x837=(cj0*cj1);
IkReal x838=((0.072)*cj4);
IkReal x839=((0.057)*x834);
IkReal x840=((0.218)*x833);
IkReal x841=((0.218)*x834);
IkReal x842=((0.057)*sj1*x833);
evalcond[0]=((((-1.0)*sj1*x839))+((r22*x838))+(((0.35)*sj1))+(((-1.0)*pz))+(((-1.0)*r20*sj5*x836))+(((-1.0)*cj5*r21*x836))+(((0.057)*cj1*x833))+(((-1.0)*sj1*x840))+(((-1.0)*cj1*x841)));
evalcond[1]=((((-1.0)*r00*sj5*x836))+(((-0.35)*x837))+((cj0*x842))+((r02*x838))+((x837*x840))+(((-1.0)*px))+((x837*x839))+(((-1.0)*cj5*r01*x836))+(((-1.0)*cj0*sj1*x841)));
evalcond[2]=((((-1.0)*r10*sj5*x836))+(((-0.35)*x835))+(((-1.0)*sj0*sj1*x841))+((x835*x840))+((x835*x839))+(((-1.0)*py))+(((-1.0)*cj5*r11*x836))+((r12*x838))+((sj0*x842)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[2];
IkReal x843=(((cj4*r00*sj5))+((r02*sj4))+((cj4*cj5*r01)));
j3eval[0]=x843;
j3eval[1]=IKsign(x843);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
IkReal x844=((1.0)*cj4);
IkReal x845=((((-1.0)*r10*sj5*x844))+(((-1.0)*cj5*r11*x844))+(((-1.0)*r12*sj4)));
j3eval[0]=x845;
j3eval[1]=IKsign(x845);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
IkReal x846=cj4*cj4;
IkReal x847=cj5*cj5;
IkReal x848=r20*r20;
IkReal x849=r21*r21;
IkReal x850=(r20*sj5);
IkReal x851=(cj5*r21);
IkReal x852=((1.0)*x848);
IkReal x853=((2.0)*cj4*r22*sj4);
IkReal x854=(x846*x847);
IkReal x855=(((x850*x853))+(((-1.0)*x852))+(((-1.0)*x852*x854))+((x846*x848))+(((2.0)*x846*x850*x851))+((x851*x853))+(((-1.0)*x846*(r22*r22)))+(((-1.0)*x849))+((x849*x854)));
j3eval[0]=x855;
j3eval[1]=IKsign(x855);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x856=cj4*cj4;
IkReal x857=cj5*cj5;
IkReal x858=r20*r20;
IkReal x859=r21*r21;
IkReal x860=((1.0)*cj5);
IkReal x861=(r21*sj2);
IkReal x862=(cj1*sj4);
IkReal x863=(cj2*sj1);
IkReal x864=(cj4*r22);
IkReal x865=(sj1*sj5);
IkReal x866=(r20*sj5);
IkReal x867=((2.0)*sj4);
IkReal x868=(cj1*cj2);
IkReal x869=(r21*sj5);
IkReal x870=(cj1*sj2);
IkReal x871=((1.0)*sj2);
IkReal x872=(cj5*r21);
IkReal x873=(r20*sj2);
IkReal x874=((1.0)*x858);
IkReal x875=(x856*x857);
CheckValue<IkReal> x876 = IKatan2WithCheck(IkReal(((((-1.0)*sj1*x864*x871))+((sj4*x865*x873))+(((-1.0)*cj2*r21*x860*x862))+((x863*x869))+((cj5*sj1*sj4*x861))+(((-1.0)*cj2*x862*x866))+(((-1.0)*r20*x860*x870))+((x864*x868))+(((-1.0)*r20*x860*x863))+((cj1*sj5*x861)))),IkReal((((cj5*r20*x868))+(((-1.0)*x862*x866*x871))+((x863*x864))+(((-1.0)*x860*x861*x862))+(((-1.0)*sj1*x860*x873))+(((-1.0)*r21*sj4*x860*x863))+(((-1.0)*x868*x869))+(((-1.0)*sj4*x863*x866))+((x861*x865))+((x864*x870)))),IKFAST_ATAN2_MAGTHRESH);
if(!x876.valid){
continue;
}
CheckValue<IkReal> x877=IKPowWithIntegerCheck(IKsign(((((-1.0)*x859))+((x864*x866*x867))+(((2.0)*x856*x866*x872))+((x856*x858))+((x864*x867*x872))+((x859*x875))+(((-1.0)*x874*x875))+(((-1.0)*x856*(r22*r22)))+(((-1.0)*x874)))),-1);
if(!x877.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x876.value)+(((1.5707963267949)*(x877.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x878=IKsin(j3);
IkReal x879=IKcos(j3);
IkReal x880=((1.0)*cj5);
IkReal x881=(cj1*cj2);
IkReal x882=(sj4*sj5);
IkReal x883=(sj1*sj2);
IkReal x884=(cj5*sj4);
IkReal x885=(r20*x879);
IkReal x886=(r10*x878);
IkReal x887=(r20*x878);
IkReal x888=((1.0)*cj2*sj1);
IkReal x889=((1.0)*cj1*sj2);
IkReal x890=(r01*x879);
IkReal x891=(r00*x878);
IkReal x892=(r11*x879);
IkReal x893=(r10*x879);
IkReal x894=(r00*x879);
IkReal x895=(r21*x879);
IkReal x896=((1.0)*cj4*x878);
IkReal x897=((1.0)*cj4*x879);
IkReal x898=((1.0)*sj5*x878);
evalcond[0]=(((r21*x878*x884))+((x882*x887))+((sj5*x895))+(((-1.0)*x881))+(((-1.0)*r22*x896))+x883+(((-1.0)*x880*x885)));
evalcond[1]=(((x884*x895))+((x882*x885))+(((-1.0)*x888))+(((-1.0)*x889))+((cj5*x887))+(((-1.0)*r22*x897))+(((-1.0)*r21*x898)));
evalcond[2]=(((x884*x890))+((cj0*x881))+((x882*x894))+((cj5*x891))+(((-1.0)*cj0*x883))+(((-1.0)*r02*x897))+(((-1.0)*r01*x898)));
evalcond[3]=((((-1.0)*sj0*x883))+((x884*x892))+((sj0*x881))+((x882*x893))+(((-1.0)*r11*x898))+(((-1.0)*r12*x897))+((cj5*x886)));
evalcond[4]=((((-1.0)*cj0*x888))+(((-1.0)*cj0*x889))+((x882*x891))+((sj5*x890))+(((-1.0)*r02*x896))+((r01*x878*x884))+(((-1.0)*x880*x894)));
evalcond[5]=(((x882*x886))+((sj5*x892))+(((-1.0)*sj0*x888))+(((-1.0)*sj0*x889))+(((-1.0)*r12*x896))+((r11*x878*x884))+(((-1.0)*x880*x893)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x899=(cj0*cj2);
IkReal x900=(r01*sj2);
IkReal x901=(cj2*r01);
IkReal x902=(cj1*sj5);
IkReal x903=(sj4*sj5);
IkReal x904=(cj4*r02);
IkReal x905=(sj1*sj2);
IkReal x906=((1.0)*cj1);
IkReal x907=((1.0)*sj4);
IkReal x908=((1.0)*r00);
IkReal x909=(cj0*sj2);
IkReal x910=(cj4*r22);
IkReal x911=(sj1*sj5);
IkReal x912=((1.0)*cj4);
IkReal x913=(cj2*r00);
IkReal x914=(cj1*cj5*sj4);
IkReal x915=((1.0)*r20*sj1);
IkReal x916=(r21*x909);
IkReal x917=(cj5*sj1*x907);
CheckValue<IkReal> x918=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj5*r11*x912))+(((-1.0)*r12*x907))+(((-1.0)*r10*sj5*x912)))),-1);
if(!x918.valid){
continue;
}
CheckValue<IkReal> x919 = IKatan2WithCheck(IkReal((((x902*x916))+((cj1*cj5*x913))+(((-1.0)*x901*x902))+(((-1.0)*cj5*x905*x908))+(((-1.0)*cj5*r20*x906*x909))+(((-1.0)*cj5*x899*x915))+((x900*x911))+((r21*x899*x911)))),IkReal(((((-1.0)*x903*x905*x908))+((cj1*x909*x910))+((x901*x914))+(((-1.0)*r20*x902*x907*x909))+(((-1.0)*cj2*x904*x906))+(((-1.0)*x899*x903*x915))+((sj4*x902*x913))+(((-1.0)*r21*x899*x917))+((sj1*x899*x910))+(((-1.0)*cj5*sj4*x906*x916))+(((-1.0)*x900*x917))+((x904*x905)))),IKFAST_ATAN2_MAGTHRESH);
if(!x919.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x918.value)))+(x919.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x920=IKsin(j3);
IkReal x921=IKcos(j3);
IkReal x922=((1.0)*cj5);
IkReal x923=(cj1*cj2);
IkReal x924=(sj4*sj5);
IkReal x925=(sj1*sj2);
IkReal x926=(cj5*sj4);
IkReal x927=(r20*x921);
IkReal x928=(r10*x920);
IkReal x929=(r20*x920);
IkReal x930=((1.0)*cj2*sj1);
IkReal x931=((1.0)*cj1*sj2);
IkReal x932=(r01*x921);
IkReal x933=(r00*x920);
IkReal x934=(r11*x921);
IkReal x935=(r10*x921);
IkReal x936=(r00*x921);
IkReal x937=(r21*x921);
IkReal x938=((1.0)*cj4*x920);
IkReal x939=((1.0)*cj4*x921);
IkReal x940=((1.0)*sj5*x920);
evalcond[0]=(((x924*x929))+(((-1.0)*r22*x938))+((r21*x920*x926))+(((-1.0)*x923))+x925+((sj5*x937))+(((-1.0)*x922*x927)));
evalcond[1]=(((x924*x927))+(((-1.0)*r22*x939))+(((-1.0)*r21*x940))+((x926*x937))+((cj5*x929))+(((-1.0)*x930))+(((-1.0)*x931)));
evalcond[2]=((((-1.0)*r01*x940))+((x924*x936))+(((-1.0)*r02*x939))+((cj0*x923))+((x926*x932))+((cj5*x933))+(((-1.0)*cj0*x925)));
evalcond[3]=((((-1.0)*r11*x940))+(((-1.0)*r12*x939))+((x924*x935))+((sj0*x923))+((x926*x934))+(((-1.0)*sj0*x925))+((cj5*x928)));
evalcond[4]=((((-1.0)*cj0*x931))+(((-1.0)*cj0*x930))+((x924*x933))+(((-1.0)*r02*x938))+((r01*x920*x926))+(((-1.0)*x922*x936))+((sj5*x932)));
evalcond[5]=((((-1.0)*r12*x938))+((x924*x928))+((r11*x920*x926))+(((-1.0)*sj0*x930))+(((-1.0)*sj0*x931))+(((-1.0)*x922*x935))+((sj5*x934)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x941=((1.0)*sj1);
IkReal x942=(cj5*r10);
IkReal x943=(cj1*cj2);
IkReal x944=(sj4*sj5);
IkReal x945=(cj4*r12);
IkReal x946=(cj2*sj0);
IkReal x947=(cj4*r22);
IkReal x948=((1.0)*r20);
IkReal x949=(sj1*sj5);
IkReal x950=(r11*sj2);
IkReal x951=(cj5*sj4);
IkReal x952=(cj1*sj0*sj2);
CheckValue<IkReal> x953 = IKatan2WithCheck(IkReal(((((-1.0)*r11*sj5*x943))+(((-1.0)*cj5*r20*x941*x946))+((r21*x946*x949))+((x949*x950))+((x942*x943))+(((-1.0)*cj5*x948*x952))+(((-1.0)*sj2*x941*x942))+((r21*sj5*x952)))),IkReal(((((-1.0)*x943*x945))+((r10*x943*x944))+(((-1.0)*r10*sj2*x941*x944))+(((-1.0)*r20*x941*x944*x946))+(((-1.0)*r21*x951*x952))+((x947*x952))+((r11*x943*x951))+((sj1*x946*x947))+(((-1.0)*x941*x950*x951))+(((-1.0)*x944*x948*x952))+((sj1*sj2*x945))+(((-1.0)*r21*x941*x946*x951)))),IKFAST_ATAN2_MAGTHRESH);
if(!x953.valid){
continue;
}
CheckValue<IkReal> x954=IKPowWithIntegerCheck(IKsign((((cj4*r00*sj5))+((r02*sj4))+((cj4*cj5*r01)))),-1);
if(!x954.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x953.value)+(((1.5707963267949)*(x954.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x955=IKsin(j3);
IkReal x956=IKcos(j3);
IkReal x957=((1.0)*cj5);
IkReal x958=(cj1*cj2);
IkReal x959=(sj4*sj5);
IkReal x960=(sj1*sj2);
IkReal x961=(cj5*sj4);
IkReal x962=(r20*x956);
IkReal x963=(r10*x955);
IkReal x964=(r20*x955);
IkReal x965=((1.0)*cj2*sj1);
IkReal x966=((1.0)*cj1*sj2);
IkReal x967=(r01*x956);
IkReal x968=(r00*x955);
IkReal x969=(r11*x956);
IkReal x970=(r10*x956);
IkReal x971=(r00*x956);
IkReal x972=(r21*x956);
IkReal x973=((1.0)*cj4*x955);
IkReal x974=((1.0)*cj4*x956);
IkReal x975=((1.0)*sj5*x955);
evalcond[0]=((((-1.0)*x958))+(((-1.0)*x957*x962))+((x959*x964))+((sj5*x972))+((r21*x955*x961))+x960+(((-1.0)*r22*x973)));
evalcond[1]=(((x961*x972))+((x959*x962))+(((-1.0)*r22*x974))+(((-1.0)*x965))+(((-1.0)*x966))+((cj5*x964))+(((-1.0)*r21*x975)));
evalcond[2]=((((-1.0)*cj0*x960))+(((-1.0)*r01*x975))+((x961*x967))+((x959*x971))+(((-1.0)*r02*x974))+((cj5*x968))+((cj0*x958)));
evalcond[3]=(((x961*x969))+((sj0*x958))+((x959*x970))+(((-1.0)*sj0*x960))+(((-1.0)*r11*x975))+(((-1.0)*r12*x974))+((cj5*x963)));
evalcond[4]=(((r01*x955*x961))+(((-1.0)*x957*x971))+(((-1.0)*cj0*x965))+(((-1.0)*cj0*x966))+((x959*x968))+(((-1.0)*r02*x973))+((sj5*x967)));
evalcond[5]=(((r11*x955*x961))+(((-1.0)*x957*x970))+(((-1.0)*sj0*x965))+(((-1.0)*sj0*x966))+((x959*x963))+(((-1.0)*r12*x973))+((sj5*x969)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
    }
}
}};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - z1 (7a70ce0f27fa37d04b013f3b00de4f62)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004b"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
